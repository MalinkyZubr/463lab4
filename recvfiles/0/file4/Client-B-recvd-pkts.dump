Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 1 ACKFlag: 0 FINFlag: 0 Payload: None
Packet - srcAddr: A dstAddr: B seqNum: 1 ackNum: 1 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: None
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: GNU 'make'
1 Overview of 'make'
2 An Introduction to Makefiles
3 Writing Makefiles
4 Writing Rules
5 Writing Recipes in Rules
6 How to Use Variables
7 Conditional Parts of Makefiles
8 Functions for Transforming Text
9 How to Run 'make'
10 Using Implicit Ru
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: les
11 Using 'make' to Update Archive Files
12 Extending GNU 'make'
13 Integrating GNU 'make'
14 Features of GNU 'make'
15 Incompatibilities and Missing Features
16 Makefile Conventions
Appendix A Quick Reference
Appendix B Errors Generated by Make
Appendi
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: x C Complex Makefile Example
Appendix D GNU Free Documentation License
Index of Concepts
Index of Functions, Variables, & Directives
GNU 'make'
1 Overview of 'make'
  1.1 How to Read This Manual
  1.2 Problems and Bugs
2 An Introduction to Makefiles
  2.1 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: What a Rule Looks Like
  2.2 A Simple Makefile
  2.3 How 'make' Processes a Makefile
  2.4 Variables Make Makefiles Simpler
  2.5 Letting 'make' Deduce the Recipes
  2.6 Another Style of Makefile
  2.7 Rules for Cleaning the Directory
3 Writing Makefiles
 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  3.1 What Makefiles Contain
    3.1.1 Splitting Long Lines
  3.2 What Name to Give Your Makefile
  3.3 Including Other Makefiles
  3.4 The Variable 'MAKEFILES'
  3.5 How Makefiles Are Remade
  3.6 Overriding Part of Another Makefile
  3.7 How 'make' Reads 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: a Makefile
  3.8 How Makefiles Are Parsed
  3.9 Secondary Expansion
4 Writing Rules
  4.1 Rule Example
  4.2 Rule Syntax
  4.3 Types of Prerequisites
  4.4 Using Wildcard Characters in File Names
    4.4.1 Wildcard Examples
    4.4.2 Pitfalls of Using Wild
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: cards
    4.4.3 The Function 'wildcard'
  4.5 Searching Directories for Prerequisites
    4.5.1 'VPATH': Search Path for All Prerequisites
    4.5.2 The 'vpath' Directive
    4.5.3 How Directory Searches are Performed
    4.5.4 Writing Recipes with Directo
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ry Search
    4.5.5 Directory Search and Implicit Rules
    4.5.6 Directory Search for Link Libraries
  4.6 Phony Targets
  4.7 Rules without Recipes or Prerequisites
  4.8 Empty Target Files to Record Events
  4.9 Special Built-in Target Names
  4.10 Mult
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: iple Targets in a Rule
  4.11 Multiple Rules for One Target
  4.12 Static Pattern Rules
    4.12.1 Syntax of Static Pattern Rules
    4.12.2 Static Pattern Rules versus Implicit Rules
  4.13 Double-Colon Rules
  4.14 Generating Prerequisites Automatically

Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 5 Writing Recipes in Rules
  5.1 Recipe Syntax
    5.1.1 Splitting Recipe Lines
    5.1.2 Using Variables in Recipes
  5.2 Recipe Echoing
  5.3 Recipe Execution
    5.3.1 Using One Shell
    5.3.2 Choosing the Shell
  5.4 Parallel Execution
    5.4.1 Disab
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ling Parallel Execution
    5.4.2 Output During Parallel Execution
    5.4.3 Input During Parallel Execution
  5.5 Errors in Recipes
  5.6 Interrupting or Killing 'make'
  5.7 Recursive Use of 'make'
    5.7.1 How the 'MAKE' Variable Works
    5.7.2 Commun
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: icating Variables to a Sub-'make'
    5.7.3 Communicating Options to a Sub-'make'
    5.7.4 The '--print-directory' Option
  5.8 Defining Canned Recipes
  5.9 Using Empty Recipes
6 How to Use Variables
  6.1 Basics of Variable References
  6.2 The Two Flav
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ors of Variables
    6.2.1 Recursively Expanded Variable Assignment
    6.2.2 Simply Expanded Variable Assignment
    6.2.3 Immediately Expanded Variable Assignment
    6.2.4 Conditional Variable Assignment
  6.3 Advanced Features for Reference to Variable
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s
    6.3.1 Substitution References
    6.3.2 Computed Variable Names
  6.4 How Variables Get Their Values
  6.5 Setting Variables
  6.6 Appending More Text to Variables
  6.7 The 'override' Directive
  6.8 Defining Multi-Line Variables
  6.9 Undefining Va
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: riables
  6.10 Variables from the Environment
  6.11 Target-specific Variable Values
  6.12 Pattern-specific Variable Values
  6.13 Suppressing Inheritance
  6.14 Other Special Variables
7 Conditional Parts of Makefiles
  7.1 Example of a Conditional
  7.2
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  Syntax of Conditionals
  7.3 Conditionals that Test Flags
8 Functions for Transforming Text
  8.1 Function Call Syntax
  8.2 Functions for String Substitution and Analysis
  8.3 Functions for File Names
  8.4 Functions for Conditionals
  8.5 The 'let' Fun
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ction
  8.6 The 'foreach' Function
  8.7 The 'file' Function
  8.8 The 'call' Function
  8.9 The 'value' Function
  8.10 The 'eval' Function
  8.11 The 'origin' Function
  8.12 The 'flavor' Function
  8.13 Functions That Control Make
  8.14 The 'shell' Fun
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ction
  8.15 The 'guile' Function
9 How to Run 'make'
  9.1 Arguments to Specify the Makefile
  9.2 Arguments to Specify the Goals
  9.3 Instead of Executing Recipes
  9.4 Avoiding Recompilation of Some Files
  9.5 Overriding Variables
  9.6 Testing the Co
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: mpilation of a Program
  9.7 Temporary Files
  9.8 Summary of Options
10 Using Implicit Rules
  10.1 Using Implicit Rules
  10.2 Catalogue of Built-In Rules
  10.3 Variables Used by Implicit Rules
  10.4 Chains of Implicit Rules
  10.5 Defining and Redefin
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ing Pattern Rules
    10.5.1 Introduction to Pattern Rules
    10.5.2 Pattern Rule Examples
    10.5.3 Automatic Variables
    10.5.4 How Patterns Match
    10.5.5 Match-Anything Pattern Rules
    10.5.6 Canceling Implicit Rules
  10.6 Defining Last-Resort
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  Default Rules
  10.7 Old-Fashioned Suffix Rules
  10.8 Implicit Rule Search Algorithm
11 Using 'make' to Update Archive Files
  11.1 Archive Members as Targets
  11.2 Implicit Rule for Archive Member Targets
    11.2.1 Updating Archive Symbol Directories

Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:   11.3 Dangers When Using Archives
  11.4 Suffix Rules for Archive Files
12 Extending GNU 'make'
  12.1 GNU Guile Integration
    12.1.1 Conversion of Guile Types
    12.1.2 Interfaces from Guile to 'make'
    12.1.3 Example Using Guile in 'make'
  12.2 Lo
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ading Dynamic Objects
    12.2.1 The 'load' Directive
    12.2.2 How Loaded Objects Are Remade
    12.2.3 Loaded Object Interface
    12.2.4 Example Loaded Object
13 Integrating GNU 'make'
  13.1 Sharing Job Slots with GNU 'make'
    13.1.1 POSIX Jobserver
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  Interaction
    13.1.2 Windows Jobserver Interaction
  13.2 Synchronized Terminal Output
14 Features of GNU 'make'
15 Incompatibilities and Missing Features
16 Makefile Conventions
  16.1 General Conventions for Makefiles
  16.2 Utilities in Makefiles
  1
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 6.3 Variables for Specifying Commands
  16.4 'DESTDIR': Support for Staged Installs
  16.5 Variables for Installation Directories
  16.6 Standard Targets for Users
  16.7 Install Command Categories
Appendix A Quick Reference
Appendix B Errors Generated by 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: Make
Appendix C Complex Makefile Example
Appendix D GNU Free Documentation License
Index of Concepts
Index of Functions, Variables, & Directives
GNU 'make'
**********

This file documents the GNU 'make' utility, which determines
automatically which pieces 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: of a large program need to be recompiled, and
issues the commands to recompile them.

   This is Edition 0.77, last updated 26 February 2023, of 'The GNU Make
Manual', for GNU 'make' version 4.4.1.

   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: , 1995, 1996,
1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021,
2022, 2023 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or m
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: odify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover Texts
     being "A GNU Manual," and with
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying cop
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ies from the FSF supports it in
     developing GNU and promoting software freedom."

1 Overview of 'make'
********************

The 'make' utility automatically determines which pieces of a large
program need to be recompiled, and issues commands to recom
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: pile them.
This manual describes GNU 'make', which was implemented by Richard
Stallman and Roland McGrath.  Development since Version 3.76 has been
handled by Paul D. Smith.

   GNU 'make' conforms to section 6.2 of 'IEEE Standard 1003.2-1992'
(POSIX.2).


Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:    Our examples show C programs, since they are most common, but you can
use 'make' with any programming language whose compiler can be run with
a shell command.  Indeed, 'make' is not limited to programs.  You can
use it to describe any task where some fi
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: les must be updated
automatically from others whenever the others change.

Preparing and Running Make
==========================

To prepare to use 'make', you must write a file called the "makefile"
that describes the relationships among files in your pro
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: gram and
provides commands for updating each file.  In a program, typically, the
executable file is updated from object files, which are in turn made by
compiling source files.

   Once a suitable makefile exists, each time you change some source
files, th
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: is simple shell command:

     make

suffices to perform all necessary recompilations.  The 'make' program
uses the makefile data base and the last-modification times of the files
to decide which of the files need to be updated.  For each of those
files, i
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: t issues the recipes recorded in the data base.

   You can provide command line arguments to 'make' to control which
files should be recompiled, or how.  *Note How to Run 'make': Running.

1.1 How to Read This Manual
===========================

If you ar
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e new to 'make', or are looking for a general introduction,
read the first few sections of each chapter, skipping the later
sections.  In each chapter, the first few sections contain introductory
or general information and the later sections contain specia
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: lized or
technical information.  The exception is the second chapter, *note An
Introduction to Makefiles: Introduction, all of which is introductory.

   If you are familiar with other 'make' programs, see *note Features of
GNU 'make': Features, which list
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s the enhancements GNU 'make' has, and
*note Incompatibilities and Missing Features: Missing, which explains
the few things GNU 'make' lacks that others have.

   For a quick summary, see *note Options Summary::, *note Quick
Reference::, and *note Special 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: Targets::.

1.2 Problems and Bugs
=====================

If you have problems with GNU 'make' or think you've found a bug, please
report it to the developers; we cannot promise to do anything but we
might well want to fix it.

   Before reporting a bug, ma
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ke sure you've actually found a real bug.
Carefully reread the documentation and see if it really says you can do
what you're trying to do.  If it's not clear whether you should be able
to do something or not, report that too; it's a bug in the
documentati
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: on!

   Before reporting a bug or trying to fix it yourself, try to isolate
it to the smallest possible makefile that reproduces the problem.  Then
send us the makefile and the exact results 'make' gave you, including
any error or warning messages.  Please
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  don't paraphrase these messages:
it's best to cut and paste them into your report.  When generating this
small makefile, be sure to not use any non-free or unusual tools in your
recipes: you can almost always emulate what such a tool would do with
simple 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: shell commands.  Finally, be sure to explain what you expected to
occur; this will help us decide whether the problem was really in the
documentation.

   Once you have a precise problem you can report it in one of two ways.
Either send electronic mail to:
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 

         bug-make@gnu.org

or use our Web-based project management tool, at:

         https://savannah.gnu.org/projects/make/

In addition to the information above, please be careful to include the
version number of 'make' you are using.  You can get th
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: is information
with the command 'make --version'.  Be sure also to include the type of
machine and operating system you are using.  One way to obtain this
information is by looking at the final lines of output from the command
'make --help'.

   If you hav
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e a code change you'd like to submit, see the 'README' file
section "Submitting Patches" for information.

2 An Introduction to Makefiles
******************************

You need a file called a "makefile" to tell 'make' what to do.  Most
often, the makefi
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: le tells 'make' how to compile and link a program.

   In this chapter, we will discuss a simple makefile that describes how
to compile and link a text editor which consists of eight C source files
and three header files.  The makefile can also tell 'make'
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  how to run
miscellaneous commands when explicitly asked (for example, to remove
certain files as a clean-up operation).  To see a more complex example
of a makefile, see *note Complex Makefile::.

   When 'make' recompiles the editor, each changed C sourc
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e file must be
recompiled.  If a header file has changed, each C source file that
includes the header file must be recompiled to be safe.  Each
compilation produces an object file corresponding to the source file.
Finally, if any source file has been recom
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: piled, all the object files,
whether newly made or saved from previous compilations, must be linked
together to produce the new executable editor.

2.1 What a Rule Looks Like
==========================

A simple makefile consists of "rules" with the follow
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ing shape:

     TARGET ... : PREREQUISITES ...
             RECIPE
             ...
             ...

   A "target" is usually the name of a file that is generated by a
program; examples of targets are executable or object files.  A target
can also be the
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  name of an action to carry out, such as 'clean' (*note
Phony Targets::).

   A "prerequisite" is a file that is used as input to create the
target.  A target often depends on several files.

   A "recipe" is an action that 'make' carries out.  A recipe ma
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: y have
more than one command, either on the same line or each on its own line.
*Please note:* you need to put a tab character at the beginning of every
recipe line!  This is an obscurity that catches the unwary.  If you
prefer to prefix your recipes with a
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  character other than tab, you can
set the '.RECIPEPREFIX' variable to an alternate character (*note
Special Variables::).

   Usually a recipe is in a rule with prerequisites and serves to create
a target file if any of the prerequisites change.  However,
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  the rule
that specifies a recipe for the target need not have prerequisites.  For
example, the rule containing the delete command associated with the
target 'clean' does not have prerequisites.

   A "rule", then, explains how and when to remake certain f
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: iles which
are the targets of the particular rule.  'make' carries out the recipe
on the prerequisites to create or update the target.  A rule can also
explain how and when to carry out an action.  *Note Writing Rules:
Rules.

   A makefile may contain oth
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: er text besides rules, but a simple
makefile need only contain rules.  Rules may look somewhat more
complicated than shown in this template, but all fit the pattern more or
less.

2.2 A Simple Makefile
=====================

Here is a straightforward makef
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ile that describes the way an executable
file called 'edit' depends on eight object files which, in turn, depend
on eight C source and three header files.

   In this example, all the C files include 'defs.h', but only those
defining editing commands inclu
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: de 'command.h', and only low level files
that change the editor buffer include 'buffer.h'.

     edit : main.o kbd.o command.o display.o \
            insert.o search.o files.o utils.o
             cc -o edit main.o kbd.o command.o display.o \
            
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:             insert.o search.o files.o utils.o

     main.o : main.c defs.h
             cc -c main.c
     kbd.o : kbd.c defs.h command.h
             cc -c kbd.c
     command.o : command.c defs.h command.h
             cc -c command.c
     display.o : disp
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: lay.c defs.h buffer.h
             cc -c display.c
     insert.o : insert.c defs.h buffer.h
             cc -c insert.c
     search.o : search.c defs.h buffer.h
             cc -c search.c
     files.o : files.c defs.h buffer.h command.h
             cc -c
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  files.c
     utils.o : utils.c defs.h
             cc -c utils.c
     clean :
             rm edit main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o

We split each long line into two lines using backslash/newline; this i
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s
like using one long line, but is easier to read.  *Note Splitting Long
Lines: Splitting Lines.

   To use this makefile to create the executable file called 'edit',
type:

     make

   To use this makefile to delete the executable file and all the objec
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: t
files from the directory, type:

     make clean

   In the example makefile, the targets include the executable file
'edit', and the object files 'main.o' and 'kbd.o'.  The prerequisites
are files such as 'main.c' and 'defs.h'.  In fact, each '.o' file 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: is
both a target and a prerequisite.  Recipes include 'cc -c main.c' and
'cc -c kbd.c'.

   When a target is a file, it needs to be recompiled or relinked if any
of its prerequisites change.  In addition, any prerequisites that are
themselves automatically
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  generated should be updated first.  In this
example, 'edit' depends on each of the eight object files; the object
file 'main.o' depends on the source file 'main.c' and on the header file
'defs.h'.

   A recipe may follow each line that contains a target a
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: nd
prerequisites.  These recipes say how to update the target file.  A tab
character (or whatever character is specified by the '.RECIPEPREFIX'
variable; *note Special Variables::) must come at the beginning of every
line in the recipe to distinguish recip
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: es from other lines in the
makefile.  (Bear in mind that 'make' does not know anything about how
the recipes work.  It is up to you to supply recipes that will update
the target file properly.  All 'make' does is execute the recipe you
have specified when 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: the target file needs to be updated.)

   The target 'clean' is not a file, but merely the name of an action.
Since you normally do not want to carry out the actions in this rule,
'clean' is not a prerequisite of any other rule.  Consequently, 'make'
never
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  does anything with it unless you tell it specifically.  Note that
this rule not only is not a prerequisite, it also does not have any
prerequisites, so the only purpose of the rule is to run the specified
recipe.  Targets that do not refer to files but ar
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e just actions are
called "phony targets".  *Note Phony Targets::, for information about
this kind of target.  *Note Errors in Recipes: Errors, to see how to
cause 'make' to ignore errors from 'rm' or any other command.

2.3 How 'make' Processes a Makefile
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 
===================================

By default, 'make' starts with the first target (not targets whose names
start with '.' unless they also contain one or more '/').  This is
called the "default goal".  ("Goals" are the targets that 'make' strives
ultim
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ately to update.  You can override this behavior using the command
line (*note Arguments to Specify the Goals: Goals.) or with the
'.DEFAULT_GOAL' special variable (*note Other Special Variables: Special
Variables.).

   In the simple example of the previo
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: us section, the default goal is to
update the executable program 'edit'; therefore, we put that rule first.

   Thus, when you give the command:

     make

'make' reads the makefile in the current directory and begins by
processing the first rule.  In the
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  example, this rule is for relinking
'edit'; but before 'make' can fully process this rule, it must process
the rules for the files that 'edit' depends on, which in this case are
the object files.  Each of these files is processed according to its own
rule
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: .  These rules say to update each '.o' file by compiling its source
file.  The recompilation must be done if the source file, or any of the
header files named as prerequisites, is more recent than the object
file, or if the object file does not exist.

   
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: The other rules are processed because their targets appear as
prerequisites of the goal.  If some other rule is not depended on by the
goal (or anything it depends on, etc.), that rule is not processed,
unless you tell 'make' to do so (with a command such 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: as 'make clean').

   Before recompiling an object file, 'make' considers updating its
prerequisites, the source file and header files.  This makefile does not
specify anything to be done for them--the '.c' and '.h' files are not
the targets of any rules--
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: so 'make' does nothing for these files.  But
'make' would update automatically generated C programs, such as those
made by Bison or Yacc, by their own rules at this time.

   After recompiling whichever object files need it, 'make' decides
whether to relin
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: k 'edit'.  This must be done if the file 'edit' does not
exist, or if any of the object files are newer than it.  If an object
file was just recompiled, it is now newer than 'edit', so 'edit' is
relinked.

   Thus, if we change the file 'insert.c' and run 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 'make', 'make' will
compile that file to update 'insert.o', and then link 'edit'.  If we
change the file 'command.h' and run 'make', 'make' will recompile the
object files 'kbd.o', 'command.o' and 'files.o' and then link the file
'edit'.

2.4 Variables Mak
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e Makefiles Simpler
====================================

In our example, we had to list all the object files twice in the rule
for 'edit' (repeated here):

     edit : main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 
             cc -o edit main.o kbd.o command.o display.o \
                        insert.o search.o files.o utils.o

   Such duplication is error-prone; if a new object file is added to the
system, we might add it to one list and forget the other.  We ca
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: n
eliminate the risk and simplify the makefile by using a variable.
"Variables" allow a text string to be defined once and substituted in
multiple places later (*note How to Use Variables: Using Variables.).

   It is standard practice for every makefile t
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: o have a variable named
'objects', 'OBJECTS', 'objs', 'OBJS', 'obj', or 'OBJ' which is a list of
all object file names.  We would define such a variable 'objects' with a
line like this in the makefile:

     objects = main.o kbd.o command.o display.o \
   
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:             insert.o search.o files.o utils.o

Then, each place we want to put a list of the object file names, we can
substitute the variable's value by writing '$(objects)' (*note How to
Use Variables: Using Variables.).

   Here is how the complete simp
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: le makefile looks when you use a
variable for the object files:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

     edit : $(objects)
             cc -o edit $(objects)
     main.o : main.c defs.h
     
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:         cc -c main.c
     kbd.o : kbd.c defs.h command.h
             cc -c kbd.c
     command.o : command.c defs.h command.h
             cc -c command.c
     display.o : display.c defs.h buffer.h
             cc -c display.c
     insert.o : insert.c defs
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: .h buffer.h
             cc -c insert.c
     search.o : search.c defs.h buffer.h
             cc -c search.c
     files.o : files.c defs.h buffer.h command.h
             cc -c files.c
     utils.o : utils.c defs.h
             cc -c utils.c
     clean :
 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:             rm edit $(objects)

2.5 Letting 'make' Deduce the Recipes
=====================================

It is not necessary to spell out the recipes for compiling the
individual C source files, because 'make' can figure them out: it has an
"implicit r
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ule" for updating a '.o' file from a correspondingly named
'.c' file using a 'cc -c' command.  For example, it will use the recipe
'cc -c main.c -o main.o' to compile 'main.c' into 'main.o'.  We can
therefore omit the recipes from the rules for the object 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: files.  *Note
Using Implicit Rules: Implicit Rules.

   When a '.c' file is used automatically in this way, it is also
automatically added to the list of prerequisites.  We can therefore omit
the '.c' files from the prerequisites, provided we omit the reci
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: pe.

   Here is the entire example, with both of these changes, and a
variable 'objects' as suggested above:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

     edit : $(objects)
             cc -o edit
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  $(objects)

     main.o : defs.h
     kbd.o : defs.h command.h
     command.o : defs.h command.h
     display.o : defs.h buffer.h
     insert.o : defs.h buffer.h
     search.o : defs.h buffer.h
     files.o : defs.h buffer.h command.h
     utils.o : defs.
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: h

     .PHONY : clean
     clean :
             rm edit $(objects)

This is how we would write the makefile in actual practice.  (The
complications associated with 'clean' are described elsewhere.  See
*note Phony Targets::, and *note Errors in Recipes: E
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: rrors.)

   Because implicit rules are so convenient, they are important.  You
will see them used frequently.

2.6 Another Style of Makefile
=============================

When the objects of a makefile are created only by implicit rules, an
alternative st
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: yle of makefile is possible.  In this style of makefile,
you group entries by their prerequisites instead of by their targets.
Here is what one looks like:

     objects = main.o kbd.o command.o display.o \
               insert.o search.o files.o utils.o

Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 
     edit : $(objects)
             cc -o edit $(objects)

     $(objects) : defs.h
     kbd.o command.o files.o : command.h
     display.o insert.o search.o files.o : buffer.h

Here 'defs.h' is given as a prerequisite of all the object files;
'command.h'
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  and 'buffer.h' are prerequisites of the specific object
files listed for them.

   Whether this is better is a matter of taste: it is more compact, but
some people dislike it because they find it clearer to put all the
information about each target in one
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  place.

2.7 Rules for Cleaning the Directory
====================================

Compiling a program is not the only thing you might want to write rules
for.  Makefiles commonly tell how to do a few other things besides
compiling a program: for example,
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  how to delete all the object files and
executables so that the directory is 'clean'.

   Here is how we could write a 'make' rule for cleaning our example
editor:

     clean:
             rm edit $(objects)

   In practice, we might want to write the rul
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e in a somewhat more
complicated manner to handle unanticipated situations.  We would do
this:

     .PHONY : clean
     clean :
             -rm edit $(objects)

This prevents 'make' from getting confused by an actual file called
'clean' and causes it to 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: continue in spite of errors from 'rm'.  (See
*note Phony Targets::, and *note Errors in Recipes: Errors.)

A rule such as this should not be placed at the beginning of the
makefile, because we do not want it to run by default!  Thus, in the
example makefil
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e, we want the rule for 'edit', which recompiles the
editor, to remain the default goal.

   Since 'clean' is not a prerequisite of 'edit', this rule will not run
at all if we give the command 'make' with no arguments.  In order to
make the rule run, we ha
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ve to type 'make clean'.  *Note How to Run
'make': Running.

3 Writing Makefiles
*******************

The information that tells 'make' how to recompile a system comes from
reading a data base called the "makefile".

3.1 What Makefiles Contain
============
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ==============

Makefiles contain five kinds of things: "explicit rules", "implicit
rules", "variable definitions", "directives", and "comments".  Rules,
variables, and directives are described at length in later chapters.

   * An "explicit rule" says whe
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: n and how to remake one or more files,
     called the rule's "targets".  It lists the other files that the
     targets depend on, called the "prerequisites" of the target, and
     may also give a recipe to use to create or update the targets.
     *Note
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  Writing Rules: Rules.

   * An "implicit rule" says when and how to remake a class of files
     based on their names.  It describes how a target may depend on a
     file with a name similar to the target and gives a recipe to create
     or update such 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: a target.  *Note Using Implicit Rules: Implicit
     Rules.

   * A "variable definition" is a line that specifies a text string
     value for a variable that can be substituted into the text later.
     The simple makefile example shows a variable defini
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: tion for
     'objects' as a list of all object files (*note Variables Make
     Makefiles Simpler: Variables Simplify.).

   * A "directive" is an instruction for 'make' to do something special
     while reading the makefile.  These include:

        * R
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: eading another makefile (*note Including Other Makefiles:
          Include.).

        * Deciding (based on the values of variables) whether to use or
          ignore a part of the makefile (*note Conditional Parts of
          Makefiles: Conditionals.).
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 

        * Defining a variable from a verbatim string containing multiple
          lines (*note Defining Multi-Line Variables: Multi-Line.).

   * '#' in a line of a makefile starts a "comment".  It and the rest of
     the line are ignored, except that 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: a trailing backslash not escaped
     by another backslash will continue the comment across multiple
     lines.  A line containing just a comment (with perhaps spaces
     before it) is effectively blank, and is ignored.  If you want a
     literal '#', e
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: scape it with a backslash (e.g., '\#').  Comments may
     appear on any line in the makefile, although they are treated
     specially in certain situations.

     You cannot use comments within variable references or function
     calls: any instance of 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: '#' will be treated literally (rather than
     as the start of a comment) inside a variable reference or function
     call.

     Comments within a recipe are passed to the shell, just as with any
     other recipe text.  The shell decides how to interpr
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: et it: whether
     or not this is a comment is up to the shell.

     Within a 'define' directive, comments are not ignored during the
     definition of the variable, but rather kept intact in the value of
     the variable.  When the variable is expande
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: d they will either be
     treated as 'make' comments or as recipe text, depending on the
     context in which the variable is evaluated.

3.1.1 Splitting Long Lines
--------------------------

Makefiles use a "line-based" syntax in which the newline char
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: acter is
special and marks the end of a statement.  GNU 'make' has no limit on
the length of a statement line, up to the amount of memory in your
computer.

   However, it is difficult to read lines which are too long to display
without wrapping or scrolli
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ng.  So, you can format your makefiles for
readability by adding newlines into the middle of a statement: you do
this by escaping the internal newlines with a backslash ('\') character.
Where we need to make a distinction we will refer to "physical lines" 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: as
a single line ending with a newline (regardless of whether it is
escaped) and a "logical line" being a complete statement including all
escaped newlines up to the first non-escaped newline.

   The way in which backslash/newline combinations are handled
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  depends
on whether the statement is a recipe line or a non-recipe line.
Handling of backslash/newline in a recipe line is discussed later (*note
Splitting Recipe Lines::).

   Outside of recipe lines, backslash/newlines are converted into a
single space c
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: haracter.  Once that is done, all whitespace around the
backslash/newline is condensed into a single space: this includes all
whitespace preceding the backslash, all whitespace at the beginning of
the line after the backslash/newline, and any consecutive
b
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ackslash/newline combinations.

   If the '.POSIX' special target is defined then backslash/newline
handling is modified slightly to conform to POSIX.2: first, whitespace
preceding a backslash is not removed and second, consecutive
backslash/newlines are n
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ot condensed.

Splitting Without Adding Whitespace
...................................

If you need to split a line but do _not_ want any whitespace added, you
can utilize a subtle trick: replace your backslash/newline pairs with
the three characters dolla
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: r sign, backslash, and newline:

     var := one$\
            word

   After 'make' removes the backslash/newline and condenses the
following line into a single space, this is equivalent to:

     var := one$ word

   Then 'make' will perform variable exp
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ansion.  The variable reference
'$ ' refers to a variable with the one-character name " " (space) which
does not exist, and so expands to the empty string, giving a final
assignment which is the equivalent of:

     var := oneword

3.2 What Name to Give Yo
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ur Makefile
===================================

By default, when 'make' looks for the makefile, it tries the following
names, in order: 'GNUmakefile', 'makefile' and 'Makefile'.

   Normally you should call your makefile either 'makefile' or
'Makefile'.  
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: (We recommend 'Makefile' because it appears prominently
near the beginning of a directory listing, right near other important
files such as 'README'.)  The first name checked, 'GNUmakefile', is not
recommended for most makefiles.  You should use this name 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: if you have a
makefile that is specific to GNU 'make', and will not be understood by
other versions of 'make'.  Other 'make' programs look for 'makefile' and
'Makefile', but not 'GNUmakefile'.

   If 'make' finds none of these names, it does not use any ma
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: kefile.
Then you must specify a goal with a command argument, and 'make' will
attempt to figure out how to remake it using only its built-in implicit
rules.  *Note Using Implicit Rules: Implicit Rules.

   If you want to use a nonstandard name for your mak
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: efile, you can
specify the makefile name with the '-f' or '--file' option.  The
arguments '-f NAME' or '--file=NAME' tell 'make' to read the file NAME
as the makefile.  If you use more than one '-f' or '--file' option, you
can specify several makefiles.  A
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ll the makefiles are effectively
concatenated in the order specified.  The default makefile names
'GNUmakefile', 'makefile' and 'Makefile' are not checked automatically
if you specify '-f' or '--file'.

3.3 Including Other Makefiles
=======================
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ======

The 'include' directive tells 'make' to suspend reading the current
makefile and read one or more other makefiles before continuing.  The
directive is a line in the makefile that looks like this:

     include FILENAMES...

FILENAMES can contain sh
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ell file name patterns.  If FILENAMES is empty,
nothing is included and no error is printed.

   Extra spaces are allowed and ignored at the beginning of the line,
but the first character must not be a tab (or the value of
'.RECIPEPREFIX')--if the line beg
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ins with a tab, it will be considered a
recipe line.  Whitespace is required between 'include' and the file
names, and between file names; extra whitespace is ignored there and at
the end of the directive.  A comment starting with '#' is allowed at the
end
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  of the line.  If the file names contain any variable or function
references, they are expanded.  *Note How to Use Variables: Using
Variables.

   For example, if you have three '.mk' files, 'a.mk', 'b.mk', and
'c.mk', and '$(bar)' expands to 'bish bash', 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: then the following
expression

     include foo *.mk $(bar)

   is equivalent to

     include foo a.mk b.mk c.mk bish bash

   When 'make' processes an 'include' directive, it suspends reading of
the containing makefile and reads from each listed file in 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: turn.  When
that is finished, 'make' resumes reading the makefile in which the
directive appears.

   One occasion for using 'include' directives is when several programs,
handled by individual makefiles in various directories, need to use a
common set of 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: variable definitions (*note Setting Variables: Setting.)
or pattern rules (*note Defining and Redefining Pattern Rules: Pattern
Rules.).

   Another such occasion is when you want to generate prerequisites from
source files automatically; the prerequisites
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  can be put in a file that
is included by the main makefile.  This practice is generally cleaner
than that of somehow appending the prerequisites to the end of the main
makefile as has been traditionally done with other versions of 'make'.
*Note Automatic 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: Prerequisites::.

   If the specified name does not start with a slash (or a drive letter
and colon when GNU Make is compiled with MS-DOS / MS-Windows path
support), and the file is not found in the current directory, several
other directories are searched
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: .  First, any directories you have
specified with the '-I' or '--include-dir' options are searched (*note
Summary of Options: Options Summary.).  Then the following directories
(if they exist) are searched, in this order: 'PREFIX/include' (normally
'/usr/l
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ocal/include' (1)) '/usr/gnu/include', '/usr/local/include',
'/usr/include'.

   The '.INCLUDE_DIRS' variable will contain the current list of
directories that make will search for included files.  *Note Other
Special Variables: Special Variables.

   You 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: can avoid searching in these default directories by adding the
command line option '-I' with the special value '-' (e.g., '-I-') to the
command line.  This will cause 'make' to forget any already-set include
directories, including the default directories.

Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 
   If an included makefile cannot be found in any of these directories
it is not an immediately fatal error; processing of the makefile
containing the 'include' continues.  Once it has finished reading
makefiles, 'make' will try to remake any that are out
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  of date or don't
exist.  *Note How Makefiles Are Remade: Remaking Makefiles.  Only after
it has failed to find a rule to remake the makefile, or it found a rule
but the recipe failed, will 'make' diagnose the missing makefile as a
fatal error.

   If you 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: want 'make' to simply ignore a makefile which does not exist
or cannot be remade, with no error message, use the '-include' directive
instead of 'include', like this:

     -include FILENAMES...

   This acts like 'include' in every way except that there i
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s no error
(not even a warning) if any of the FILENAMES (or any prerequisites of
any of the FILENAMES) do not exist or cannot be remade.

   For compatibility with some other 'make' implementations, 'sinclude'
is another name for '-include'.

   ----------
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  Footnotes ----------

   (1) GNU Make compiled for MS-DOS and MS-Windows behaves as if PREFIX
has been defined to be the root of the DJGPP tree hierarchy.

3.4 The Variable 'MAKEFILES'
============================

If the environment variable 'MAKEFILES' 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: is defined, 'make' considers its
value as a list of names (separated by whitespace) of additional
makefiles to be read before the others.  This works much like the
'include' directive: various directories are searched for those files
(*note Including Other
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  Makefiles: Include.).  In addition, the default
goal is never taken from one of these makefiles (or any makefile
included by them) and it is not an error if the files listed in
'MAKEFILES' are not found.

   The main use of 'MAKEFILES' is in communication
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  between recursive
invocations of 'make' (*note Recursive Use of 'make': Recursion.).  It
usually is not desirable to set the environment variable before a
top-level invocation of 'make', because it is usually better not to mess
with a makefile from outsid
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e.  However, if you are running 'make'
without a specific makefile, a makefile in 'MAKEFILES' can do useful
things to help the built-in implicit rules work better, such as defining
search paths (*note Directory Search::).

   Some users are tempted to set 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 'MAKEFILES' in the environment
automatically on login, and program makefiles to expect this to be done.
This is a very bad idea, because such makefiles will fail to work if run
by anyone else.  It is much better to write explicit 'include'
directives in th
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e makefiles.  *Note Including Other Makefiles: Include.

3.5 How Makefiles Are Remade
============================

Sometimes makefiles can be remade from other files, such as RCS or SCCS
files.  If a makefile can be remade from other files, you probably w
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ant
'make' to get an up-to-date version of the makefile to read in.

   To this end, after reading in all makefiles 'make' will consider each
as a goal target, in the order in which they were processed, and attempt
to update it.  If parallel builds (*note 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: Parallel Execution: Parallel.)
are enabled then makefiles will be rebuilt in parallel as well.

   If a makefile has a rule which says how to update it (found either in
that very makefile or in another one) or if an implicit rule applies to
it (*note Using
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  Implicit Rules: Implicit Rules.), it will be updated if
necessary.  After all makefiles have been checked, if any have actually
been changed, 'make' starts with a clean slate and reads all the
makefiles over again.  (It will also attempt to update each of
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  them over
again, but normally this will not change them again, since they are
already up to date.)  Each restart will cause the special variable
'MAKE_RESTARTS' to be updated (*note Special Variables::).

   If you know that one or more of your makefiles 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: cannot be remade and
you want to keep 'make' from performing an implicit rule search on them,
perhaps for efficiency reasons, you can use any normal method of
preventing implicit rule look-up to do so.  For example, you can write
an explicit rule with the 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: makefile as the target, and an empty recipe
(*note Using Empty Recipes: Empty Recipes.).

   If the makefiles specify a double-colon rule to remake a file with a
recipe but no prerequisites, that file will always be remade (*note
Double-Colon::).  In the c
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ase of makefiles, a makefile that has a
double-colon rule with a recipe but no prerequisites will be remade
every time 'make' is run, and then again after 'make' starts over and
reads the makefiles in again.  This would cause an infinite loop: 'make'
would
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  constantly remake the makefile and restart, and never do anything
else.  So, to avoid this, 'make' will *not* attempt to remake makefiles
which are specified as targets of a double-colon rule with a recipe but
no prerequisites.

   Phony targets (*note Ph
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ony Targets::) have the same effect: they are
never considered up-to-date and so an included file marked as phony
would cause 'make' to restart continuously.  To avoid this 'make' will
not attempt to remake makefiles which are marked phony.

   You can tak
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e advantage of this to optimize startup time: if you know
you don't need your 'Makefile' to be remade you can prevent make from
trying to remake it by adding either:

     .PHONY: Makefile

   or:

     Makefile:: ;

   If you do not specify any makefiles 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: to be read with '-f' or '--file'
options, 'make' will try the default makefile names; *note What Name to
Give Your Makefile: Makefile Names.  Unlike makefiles explicitly
requested with '-f' or '--file' options, 'make' is not certain that
these makefiles sh
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ould exist.  However, if a default makefile does not
exist but can be created by running 'make' rules, you probably want the
rules to be run so that the makefile can be used.

   Therefore, if none of the default makefiles exists, 'make' will try
to make e
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ach of them until it succeeds in making one, or it runs out of
names to try.  Note that it is not an error if 'make' cannot find or
make any makefile; a makefile is not always necessary.

   When you use the '-t' or '--touch' option (*note Instead of Execu
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ting
Recipes: Instead of Execution.), you would not want to use an
out-of-date makefile to decide which targets to touch.  So the '-t'
option has no effect on updating makefiles; they are really updated even
if '-t' is specified.  Likewise, '-q' (or '--que
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: stion') and '-n' (or
'--just-print') do not prevent updating of makefiles, because an
out-of-date makefile would result in the wrong output for other targets.
Thus, 'make -f mfile -n foo' will update 'mfile', read it in, and then
print the recipe to update
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  'foo' and its prerequisites without running
it.  The recipe printed for 'foo' will be the one specified in the
updated contents of 'mfile'.

   However, on occasion you might actually wish to prevent updating of
even the makefiles.  You can do this by spe
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: cifying the makefiles as
goals in the command line as well as specifying them as makefiles.  When
the makefile name is specified explicitly as a goal, the options '-t'
and so on do apply to them.

   Thus, 'make -f mfile -n mfile foo' would read the makefi
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: le 'mfile',
print the recipe needed to update it without actually running it, and
then print the recipe needed to update 'foo' without running that.  The
recipe for 'foo' will be the one specified by the existing contents of
'mfile'.

3.6 Overriding Part o
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: f Another Makefile
=======================================

Sometimes it is useful to have a makefile that is mostly just like
another makefile.  You can often use the 'include' directive to include
one in the other, and add more targets or variable defini
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: tions.
However, it is invalid for two makefiles to give different recipes for
the same target.  But there is another way.

   In the containing makefile (the one that wants to include the other),
you can use a match-anything pattern rule to say that to rem
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ake any
target that cannot be made from the information in the containing
makefile, 'make' should look in another makefile.  *Note Pattern
Rules::, for more information on pattern rules.

   For example, if you have a makefile called 'Makefile' that says h
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ow
to make the target 'foo' (and other targets), you can write a makefile
called 'GNUmakefile' that contains:

     foo:
             frobnicate > foo

     %: force
             @$(MAKE) -f Makefile $@
     force: ;

   If you say 'make foo', 'make' will 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: find 'GNUmakefile', read it, and
see that to make 'foo', it needs to run the recipe 'frobnicate > foo'.
If you say 'make bar', 'make' will find no way to make 'bar' in
'GNUmakefile', so it will use the recipe from the pattern rule: 'make -f
Makefile bar'. 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  If 'Makefile' provides a rule for updating 'bar', 'make'
will apply the rule.  And likewise for any other target that
'GNUmakefile' does not say how to make.

   The way this works is that the pattern rule has a pattern of just
'%', so it matches any targ
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: et whatever.  The rule specifies a
prerequisite 'force', to guarantee that the recipe will be run even if
the target file already exists.  We give the 'force' target an empty
recipe to prevent 'make' from searching for an implicit rule to build
it--otherwi
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: se it would apply the same match-anything rule to 'force'
itself and create a prerequisite loop!

3.7 How 'make' Reads a Makefile
===============================

GNU 'make' does its work in two distinct phases.  During the first phase
it reads all the mak
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: efiles, included makefiles, etc.  and internalizes
all the variables and their values and implicit and explicit rules, and
builds a dependency graph of all the targets and their prerequisites.
During the second phase, 'make' uses this internalized data to 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: determine
which targets need to be updated and run the recipes necessary to update
them.

   It's important to understand this two-phase approach because it has a
direct impact on how variable and function expansion happens; this is
often a source of some 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: confusion when writing makefiles.  Below is a
summary of the different constructs that can be found in a makefile, and
the phase in which expansion happens for each part of the construct.

   We say that expansion is "immediate" if it happens during the fi
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: rst
phase: 'make' will expand that part of the construct as the makefile is
parsed.  We say that expansion is "deferred" if it is not immediate.
Expansion of a deferred construct part is delayed until the expansion is
used: either when it is referenced in 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: an immediate context, or when it
is needed during the second phase.

   You may not be familiar with some of these constructs yet.  You can
reference this section as you become familiar with them, in later
chapters.

Variable Assignment
-------------------
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 

Variable definitions are parsed as follows:

     IMMEDIATE = DEFERRED
     IMMEDIATE ?= DEFERRED
     IMMEDIATE := IMMEDIATE
     IMMEDIATE ::= IMMEDIATE
     IMMEDIATE :::= IMMEDIATE-WITH-ESCAPE
     IMMEDIATE += DEFERRED or IMMEDIATE
     IMMEDIATE !=
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  IMMEDIATE

     define IMMEDIATE
       DEFERRED
     endef

     define IMMEDIATE =
       DEFERRED
     endef

     define IMMEDIATE ?=
       DEFERRED
     endef

     define IMMEDIATE :=
       IMMEDIATE
     endef

     define IMMEDIATE ::=
       IM
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: MEDIATE
     endef

     define IMMEDIATE :::=
       IMMEDIATE-WITH-ESCAPE
     endef

     define IMMEDIATE +=
       DEFERRED or IMMEDIATE
     endef

     define IMMEDIATE !=
       IMMEDIATE
     endef

   For the append operator '+=', the right-hand 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: side is considered
immediate if the variable was previously set as a simple variable (':='
or '::='), and deferred otherwise.

   For the IMMEDIATE-WITH-ESCAPE operator ':::=', the value on the
right-hand side is immediately expanded but then escaped (that
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  is, all
instances of '$' in the result of the expansion are replaced with '$$').

   For the shell assignment operator '!=', the right-hand side is
evaluated immediately and handed to the shell.  The result is stored in
the variable named on the left, and
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  that variable is considered a
recursively expanded variable (and will thus be re-evaluated on each
reference).

Conditional Directives
----------------------

Conditional directives are parsed immediately.  This means, for example,
that automatic variable
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s cannot be used in conditional directives, as
automatic variables are not set until the recipe for that rule is
invoked.  If you need to use automatic variables in a conditional
directive you _must_ move the condition into the recipe and use shell
conditi
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: onal syntax instead.

Rule Definition
---------------

A rule is always expanded the same way, regardless of the form:

     IMMEDIATE : IMMEDIATE ; DEFERRED
             DEFERRED

   That is, the target and prerequisite sections are expanded
immediately, 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: and the recipe used to build the target is always deferred.
This is true for explicit rules, pattern rules, suffix rules, static
pattern rules, and simple prerequisite definitions.

3.8 How Makefiles Are Parsed
============================

GNU 'make' pars
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: es makefiles line-by-line.  Parsing proceeds using the
following steps:

  1. Read in a full logical line, including backslash-escaped lines
     (*note Splitting Long Lines: Splitting Lines.).

  2. Remove comments (*note What Makefiles Contain: Makefile 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: Contents.).

  3. If the line begins with the recipe prefix character and we are in a
     rule context, add the line to the current recipe and read the next
     line (*note Recipe Syntax::).

  4. Expand elements of the line which appear in an _immediate
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: _
     expansion context (*note How 'make' Reads a Makefile: Reading
     Makefiles.).

  5. Scan the line for a separator character, such as ':' or '=', to
     determine whether the line is a macro assignment or a rule (*note
     Recipe Syntax::).

  6.
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  Internalize the resulting operation and read the next line.

   An important consequence of this is that a macro can expand to an
entire rule, _if it is one line long_.  This will work:

     myrule = target : ; echo built

     $(myrule)

   However, thi
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s will not work because 'make' does not re-split lines
after it has expanded them:

     define myrule
     target:
             echo built
     endef

     $(myrule)

   The above makefile results in the definition of a target 'target'
with prerequisites 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 'echo' and 'built', as if the makefile contained
'target: echo built', rather than a rule with a recipe.  Newlines still
present in a line after expansion is complete are ignored as normal
whitespace.

   In order to properly expand a multi-line macro you 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: must use the
'eval' function: this causes the 'make' parser to be run on the results
of the expanded macro (*note Eval Function::).

3.9 Secondary Expansion
=======================

Previously we learned that GNU 'make' works in two distinct phases: a
read
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: -in phase and a target-update phase (*note How 'make' Reads a
Makefile: Reading Makefiles.).  GNU Make also has the ability to enable
a _second expansion_ of the prerequisites (only) for some or all targets
defined in the makefile.  In order for this secon
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: d expansion to occur,
the special target '.SECONDEXPANSION' must be defined before the first
prerequisite list that makes use of this feature.

   If '.SECONDEXPANSION' is defined then when GNU 'make' needs to check
the prerequisites of a target, the prere
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: quisites are expanded a _second
time_.  In most circumstances this secondary expansion will have no
effect, since all variable and function references will have been
expanded during the initial parsing of the makefiles.  In order to take
advantage of the s
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: econdary expansion phase of the parser, then, it's
necessary to _escape_ the variable or function reference in the
makefile.  In this case the first expansion merely un-escapes the
reference but doesn't expand it, and expansion is left to the secondary
exp
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ansion phase.  For example, consider this makefile:

     .SECONDEXPANSION:
     ONEVAR = onefile
     TWOVAR = twofile
     myfile: $(ONEVAR) $$(TWOVAR)

   After the first expansion phase the prerequisites list of the
'myfile' target will be 'onefile' an
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: d '$(TWOVAR)'; the first (unescaped)
variable reference to ONEVAR is expanded, while the second (escaped)
variable reference is simply unescaped, without being recognized as a
variable reference.  Now during the secondary expansion the first word
is expand
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ed again but since it contains no variable or function
references it remains the value 'onefile', while the second word is now
a normal reference to the variable TWOVAR, which is expanded to the
value 'twofile'.  The final result is that there are two prer
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: equisites,
'onefile' and 'twofile'.

   Obviously, this is not a very interesting case since the same result
could more easily have been achieved simply by having both variables
appear, unescaped, in the prerequisites list.  One difference becomes
apparent
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  if the variables are reset; consider this example:

     .SECONDEXPANSION:
     AVAR = top
     onefile: $(AVAR)
     twofile: $$(AVAR)
     AVAR = bottom

   Here the prerequisite of 'onefile' will be expanded immediately, and
resolve to the value 'top',
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  while the prerequisite of 'twofile' will not
be full expanded until the secondary expansion and yield a value of
'bottom'.

   This is marginally more exciting, but the true power of this feature
only becomes apparent when you discover that secondary expa
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: nsions always
take place within the scope of the automatic variables for that target.
This means that you can use variables such as '$@', '$*', etc.  during
the second expansion and they will have their expected values, just as
in the recipe.  All you have
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  to do is defer the expansion by escaping
the '$'.  Also, secondary expansion occurs for both explicit and
implicit (pattern) rules.  Knowing this, the possible uses for this
feature increase dramatically.  For example:

     .SECONDEXPANSION:
     main_OB
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: JS := main.o try.o test.o
     lib_OBJS := lib.o api.o

     main lib: $$($$@_OBJS)

   Here, after the initial expansion the prerequisites of both the
'main' and 'lib' targets will be '$($@_OBJS)'.  During the secondary
expansion, the '$@' variable is set
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  to the name of the target and so the
expansion for the 'main' target will yield '$(main_OBJS)', or 'main.o
try.o test.o', while the secondary expansion for the 'lib' target will
yield '$(lib_OBJS)', or 'lib.o api.o'.

   You can also mix in functions here
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: , as long as they are properly
escaped:

     main_SRCS := main.c try.c test.c
     lib_SRCS := lib.c api.c

     .SECONDEXPANSION:
     main lib: $$(patsubst %.c,%.o,$$($$@_SRCS))

   This version allows users to specify source files rather than object
fi
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: les, but gives the same resulting prerequisites list as the previous
example.

   Evaluation of automatic variables during the secondary expansion
phase, especially of the target name variable '$$@', behaves similarly
to evaluation within recipes.  However
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: , there are some subtle
differences and "corner cases" which come into play for the different
types of rule definitions that 'make' understands.  The subtleties of
using the different automatic variables are described below.

Secondary Expansion of Explici
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: t Rules
-------------------------------------

During the secondary expansion of explicit rules, '$$@' and '$$%'
evaluate, respectively, to the file name of the target and, when the
target is an archive member, the target member name.  The '$$<' variable
e
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: valuates to the first prerequisite in the first rule for this target.
'$$^' and '$$+' evaluate to the list of all prerequisites of rules _that
have already appeared_ for the same target ('$$+' with repetitions and
'$$^' without).  The following example wil
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: l help illustrate these
behaviors:

     .SECONDEXPANSION:

     foo: foo.1 bar.1 $$< $$^ $$+    # line #1

     foo: foo.2 bar.2 $$< $$^ $$+    # line #2

     foo: foo.3 bar.3 $$< $$^ $$+    # line #3

   In the first prerequisite list, all three variabl
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: es ('$$<', '$$^',
and '$$+') expand to the empty string.  In the second, they will have
values 'foo.1', 'foo.1 bar.1', and 'foo.1 bar.1' respectively.  In the
third they will have values 'foo.1', 'foo.1 bar.1 foo.2 bar.2', and
'foo.1 bar.1 foo.2 bar.2 foo.
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 1 foo.1 bar.1 foo.1 bar.1' respectively.

   Rules undergo secondary expansion in makefile order, except that the
rule with the recipe is always evaluated last.

   The variables '$$?' and '$$*' are not available and expand to the
empty string.

Secondary 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: Expansion of Static Pattern Rules
-------------------------------------------

Rules for secondary expansion of static pattern rules are identical to
those for explicit rules, above, with one exception: for static pattern
rules the '$$*' variable is set to
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  the pattern stem.  As with explicit
rules, '$$?' is not available and expands to the empty string.

Secondary Expansion of Implicit Rules
-------------------------------------

As 'make' searches for an implicit rule, it substitutes the stem and
then perf
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: orms secondary expansion for every rule with a matching target
pattern.  The value of the automatic variables is derived in the same
fashion as for static pattern rules.  As an example:

     .SECONDEXPANSION:

     foo: bar

     foo foz: fo%: bo%

     %
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: oo: $$< $$^ $$+ $$*

   When the implicit rule is tried for target 'foo', '$$<' expands to
'bar', '$$^' expands to 'bar boo', '$$+' also expands to 'bar boo', and
'$$*' expands to 'f'.

   Note that the directory prefix (D), as described in *note Implicit

Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: Rule Search Algorithm: Implicit Rule Search, is appended (after
expansion) to all the patterns in the prerequisites list.  As an
example:

     .SECONDEXPANSION:

     /tmp/foo.o:

     %.o: $$(addsuffix /%.c,foo bar) foo.h
             @echo $^

   The pr
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: erequisite list printed, after the secondary expansion and
directory prefix reconstruction, will be '/tmp/foo/foo.c /tmp/bar/foo.c
foo.h'.  If you are not interested in this reconstruction, you can use
'$$*' instead of '%' in the prerequisites list.

4 Wri
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ting Rules
***************

A "rule" appears in the makefile and says when and how to remake certain
files, called the rule's "targets" (most often only one per rule).  It
lists the other files that are the "prerequisites" of the target, and
the "recipe" t
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: o use to create or update the target.

   The order of rules is not significant, except for determining the
"default goal": the target for 'make' to consider, if you do not
otherwise specify one.  The default goal is the first target of the
first rule in t
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: he first makefile.  There are two exceptions: a target
starting with a period is not a default unless it also contains one or
more slashes, '/'; and, a target that defines a pattern rule has no
effect on the default goal.  (*Note Defining and Redefining Pa
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ttern
Rules: Pattern Rules.)

   Therefore, we usually write the makefile so that the first rule is
the one for compiling the entire program or all the programs described
by the makefile (often with a target called 'all').  *Note Arguments to
Specify the G
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: oals: Goals.

4.1 Rule Example
================

Here is an example of a rule:

     foo.o : foo.c defs.h       # module for twiddling the frobs
             cc -c -g foo.c

   Its target is 'foo.o' and its prerequisites are 'foo.c' and 'defs.h'.
It has on
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e command in the recipe: 'cc -c -g foo.c'.  The recipe starts
with a tab to identify it as a recipe.

   This rule says two things:

   * How to decide whether 'foo.o' is out of date: it is out of date if
     it does not exist, or if either 'foo.c' or 'de
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: fs.h' is more recent
     than it.

   * How to update the file 'foo.o': by running 'cc' as stated.  The
     recipe does not explicitly mention 'defs.h', but we presume that
     'foo.c' includes it, and that is why 'defs.h' was added to the
     prerequi
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: sites.

4.2 Rule Syntax
===============

In general, a rule looks like this:

     TARGETS : PREREQUISITES
             RECIPE
             ...

or like this:

     TARGETS : PREREQUISITES ; RECIPE
             RECIPE
             ...

   The TARGETS are f
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ile names, separated by spaces.  Wildcard characters
may be used (*note Using Wildcard Characters in File Names: Wildcards.)
and a name of the form 'A(M)' represents member M in archive file A
(*note Archive Members as Targets: Archive Members.).  Usually 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: there is
only one target per rule, but occasionally there is a reason to have
more (*note Multiple Targets in a Rule: Multiple Targets.).

   The RECIPE lines start with a tab character (or the first character
in the value of the '.RECIPEPREFIX' variable; 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: *note Special
Variables::).  The first recipe line may appear on the line after the
prerequisites, with a tab character, or may appear on the same line,
with a semicolon.  Either way, the effect is the same.  There are other
differences in the syntax of re
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: cipes.  *Note Writing Recipes in Rules:
Recipes.

   Because dollar signs are used to start 'make' variable references, if
you really want a dollar sign in a target or prerequisite you must write
two of them, '$$' (*note How to Use Variables: Using Variabl
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: es.).  If
you have enabled secondary expansion (*note Secondary Expansion::) and
you want a literal dollar sign in the prerequisites list, you must
actually write _four_ dollar signs ('$$$$').

   You may split a long line by inserting a backslash followed
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  by a
newline, but this is not required, as 'make' places no limit on the
length of a line in a makefile.

   A rule tells 'make' two things: when the targets are out of date, and
how to update them when necessary.

   The criterion for being out of date i
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s specified in terms of the
PREREQUISITES, which consist of file names separated by spaces.
(Wildcards and archive members (*note Archives::) are allowed here too.)
A target is out of date if it does not exist or if it is older than any
of the prerequisite
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s (by comparison of last-modification times).  The
idea is that the contents of the target file are computed based on
information in the prerequisites, so if any of the prerequisites
changes, the contents of the existing target file are no longer
necessari
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ly valid.

   How to update is specified by a RECIPE.  This is one or more lines to
be executed by the shell (normally 'sh'), but with some extra features
(*note Writing Recipes in Rules: Recipes.).

4.3 Types of Prerequisites
==========================

T
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: here are two different types of prerequisites understood by GNU 'make':
normal prerequisites, described in the previous section, and
"order-only" prerequisites.  A normal prerequisite makes two statements:
first, it imposes an order in which recipes will b
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e invoked: the recipes
for all prerequisites of a target will be completed before the recipe
for the target is started.  Second, it imposes a dependency
relationship: if any prerequisite is newer than the target, then the
target is considered out-of-date a
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: nd must be rebuilt.

   Normally, this is exactly what you want: if a target's prerequisite
is updated, then the target should also be updated.

   Occasionally you may want to ensure that a prerequisite is built
before a target, but _without_ forcing the 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: target to be updated if the
prerequisite is updated.  "Order-only" prerequisites are used to create
this type of relationship.  Order-only prerequisites can be specified by
placing a pipe symbol ('|') in the prerequisites list: any prerequisites
to the lef
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: t of the pipe symbol are normal; any prerequisites to the
right are order-only:

     TARGETS : NORMAL-PREREQUISITES | ORDER-ONLY-PREREQUISITES

   The normal prerequisites section may of course be empty.  Also, you
may still declare multiple lines of prer
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: equisites for the same target:
they are appended appropriately (normal prerequisites are appended to
the list of normal prerequisites; order-only prerequisites are appended
to the list of order-only prerequisites).  Note that if you declare the
same file t
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: o be both a normal and an order-only prerequisite, the normal
prerequisite takes precedence (since they have a strict superset of the
behavior of an order-only prerequisite).

   Order-only prerequisites are never checked when determining if the
target is 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: out of date; even order-only prerequisites marked as phony
(*note Phony Targets::) will not cause the target to be rebuilt.

   Consider an example where your targets are to be placed in a separate
directory, and that directory might not exist before 'make
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ' is run.  In
this situation, you want the directory to be created before any targets
are placed into it but, because the timestamps on directories change
whenever a file is added, removed, or renamed, we certainly don't want
to rebuild all the targets whe
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: never the directory's timestamp changes.
One way to manage this is with order-only prerequisites: make the
directory an order-only prerequisite on all the targets:

     OBJDIR := objdir
     OBJS := $(addprefix $(OBJDIR)/,foo.o bar.o baz.o)

     $(OBJDIR
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: )/%.o : %.c
             $(COMPILE.c) $(OUTPUT_OPTION) $<

     all: $(OBJS)

     $(OBJS): | $(OBJDIR)

     $(OBJDIR):
             mkdir $(OBJDIR)

   Now the rule to create the 'objdir' directory will be run, if needed,
before any '.o' is built, but no
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  '.o' will be built because the 'objdir'
directory timestamp changed.

4.4 Using Wildcard Characters in File Names
===========================================

A single file name can specify many files using "wildcard characters".
The wildcard characters i
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: n 'make' are '*', '?' and '[...]', the same as
in the Bourne shell.  For example, '*.c' specifies a list of all the
files (in the working directory) whose names end in '.c'.

   If an expression matches multiple files then the results will be
sorted.(1)  H
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: owever multiple expressions will not be globally sorted.
For example, '*.c *.h' will list all the files whose names end in '.c',
sorted, followed by all the files whose names end in '.h', sorted.

   The character '~' at the beginning of a file name also h
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: as special
significance.  If alone, or followed by a slash, it represents your home
directory.  For example '~/bin' expands to '/home/you/bin'.  If the '~'
is followed by a word, the string represents the home directory of the
user named by that word.  For
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  example '~john/bin' expands to
'/home/john/bin'.  On systems which don't have a home directory for each
user (such as MS-DOS or MS-Windows), this functionality can be simulated
by setting the environment variable HOME.

   Wildcard expansion is performed 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: by 'make' automatically in targets
and in prerequisites.  In recipes, the shell is responsible for wildcard
expansion.  In other contexts, wildcard expansion happens only if you
request it explicitly with the 'wildcard' function.

   The special significan
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ce of a wildcard character can be turned off by
preceding it with a backslash.  Thus, 'foo\*bar' would refer to a
specific file whose name consists of 'foo', an asterisk, and 'bar'.

   ---------- Footnotes ----------

   (1) Some older versions of GNU 'ma
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ke' did not sort the results of
wildcard expansion.

4.4.1 Wildcard Examples
-----------------------

Wildcards can be used in the recipe of a rule, where they are expanded
by the shell.  For example, here is a rule to delete all the object
files:

     cl
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ean:
             rm -f *.o

   Wildcards are also useful in the prerequisites of a rule.  With the
following rule in the makefile, 'make print' will print all the '.c'
files that have changed since the last time you printed them:

     print: *.c
        
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:      lpr -p $?
             touch print

This rule uses 'print' as an empty target file; see *note Empty Target
Files to Record Events: Empty Targets.  (The automatic variable '$?' is
used to print only those files that have changed; see *note Automatic
Va
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: riables::.)

   Wildcard expansion does not happen when you define a variable.  Thus,
if you write this:

     objects = *.o

then the value of the variable 'objects' is the actual string '*.o'.
However, if you use the value of 'objects' in a target or pre
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: requisite,
wildcard expansion will take place there.  If you use the value of
'objects' in a recipe, the shell may perform wildcard expansion when the
recipe runs.  To set 'objects' to the expansion, instead use:

     objects := $(wildcard *.o)

*Note Wil
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: dcard Function::.

4.4.2 Pitfalls of Using Wildcards
---------------------------------

Now here is an example of a naive way of using wildcard expansion, that
does not do what you would intend.  Suppose you would like to say that
the executable file 'foo'
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  is made from all the object files in the
directory, and you write this:

     objects = *.o

     foo : $(objects)
             cc -o foo $(CFLAGS) $(objects)

The value of 'objects' is the actual string '*.o'.  Wildcard expansion
happens in the rule for 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 'foo', so that each _existing_ '.o' file becomes
a prerequisite of 'foo' and will be recompiled if necessary.

   But what if you delete all the '.o' files?  When a wildcard matches
no files, it is left as it is, so then 'foo' will depend on the
oddly-name
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: d file '*.o'.  Since no such file is likely to exist, 'make'
will give you an error saying it cannot figure out how to make '*.o'.
This is not what you want!

   Actually it is possible to obtain the desired result with wildcard
expansion, but you need mor
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e sophisticated techniques, including the
'wildcard' function and string substitution.  *Note The Function
'wildcard': Wildcard Function.

   Microsoft operating systems (MS-DOS and MS-Windows) use backslashes
to separate directories in pathnames, like so:
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 

       c:\foo\bar\baz.c

   This is equivalent to the Unix-style 'c:/foo/bar/baz.c' (the 'c:'
part is the so-called drive letter).  When 'make' runs on these systems,
it supports backslashes as well as the Unix-style forward slashes in
pathnames.  Howeve
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: r, this support does _not_ include the wildcard
expansion, where backslash is a quote character.  Therefore, you _must_
use Unix-style slashes in these cases.

4.4.3 The Function 'wildcard'
-----------------------------

Wildcard expansion happens automati
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: cally in rules.  But wildcard
expansion does not normally take place when a variable is set, or inside
the arguments of a function.  If you want to do wildcard expansion in
such places, you need to use the 'wildcard' function, like this:

     $(wildcard P
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ATTERN...)

This string, used anywhere in a makefile, is replaced by a
space-separated list of names of existing files that match one of the
given file name patterns.  If no existing file name matches a pattern,
then that pattern is omitted from the output
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  of the 'wildcard' function.
Note that this is different from how unmatched wildcards behave in
rules, where they are used verbatim rather than ignored (*note Wildcard
Pitfall::).

   As with wildcard expansion in rules, the results of the 'wildcard'
funct
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ion are sorted.  But again, each individual expression is sorted
separately, so '$(wildcard *.c *.h)' will expand to all files matching
'.c', sorted, followed by all files matching '.h', sorted.

   One use of the 'wildcard' function is to get a list of al
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: l the C
source files in a directory, like this:

     $(wildcard *.c)

   We can change the list of C source files into a list of object files
by replacing the '.c' suffix with '.o' in the result, like this:

     $(patsubst %.c,%.o,$(wildcard *.c))

(Here
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  we have used another function, 'patsubst'.  *Note Functions for
String Substitution and Analysis: Text Functions.)

   Thus, a makefile to compile all C source files in the directory and
then link them together could be written as follows:

     objects :
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: = $(patsubst %.c,%.o,$(wildcard *.c))

     foo : $(objects)
             cc -o foo $(objects)

(This takes advantage of the implicit rule for compiling C programs, so
there is no need to write explicit rules for compiling the files.  *Note
The Two Flavors
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  of Variables: Flavors, for an explanation of ':=', which
is a variant of '='.)

4.5 Searching Directories for Prerequisites
===========================================

For large systems, it is often desirable to put sources in a separate
directory from t
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: he binaries.  The "directory search" features of 'make'
facilitate this by searching several directories automatically to find a
prerequisite.  When you redistribute the files among directories, you do
not need to change the individual rules, just the sear
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ch paths.

4.5.1 'VPATH': Search Path for All Prerequisites
------------------------------------------------

The value of the 'make' variable 'VPATH' specifies a list of directories
that 'make' should search.  Most often, the directories are expected to
c
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ontain prerequisite files that are not in the current directory;
however, 'make' uses 'VPATH' as a search list for both prerequisites and
targets of rules.

   Thus, if a file that is listed as a target or prerequisite does not
exist in the current directo
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ry, 'make' searches the directories listed
in 'VPATH' for a file with that name.  If a file is found in one of
them, that file may become the prerequisite (see below).  Rules may then
specify the names of files in the prerequisite list as if they all
exist
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ed in the current directory.  *Note Writing Recipes with Directory
Search: Recipes/Search.

   In the 'VPATH' variable, directory names are separated by colons or
blanks.  The order in which directories are listed is the order followed
by 'make' in its sea
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: rch.  (On MS-DOS and MS-Windows, semi-colons are
used as separators of directory names in 'VPATH', since the colon can be
used in the pathname itself, after the drive letter.)

   For example,

     VPATH = src:../headers

specifies a path containing two d
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: irectories, 'src' and '../headers',
which 'make' searches in that order.

   With this value of 'VPATH', the following rule,

     foo.o : foo.c

is interpreted as if it were written like this:

     foo.o : src/foo.c

assuming the file 'foo.c' does not ex
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ist in the current directory but is
found in the directory 'src'.

4.5.2 The 'vpath' Directive
---------------------------

Similar to the 'VPATH' variable, but more selective, is the 'vpath'
directive (note lower case), which allows you to specify a searc
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: h path
for a particular class of file names: those that match a particular
pattern.  Thus you can supply certain search directories for one class
of file names and other directories (or none) for other file names.

   There are three forms of the 'vpath' d
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: irective:

'vpath PATTERN DIRECTORIES'
     Specify the search path DIRECTORIES for file names that match
     PATTERN.

     The search path, DIRECTORIES, is a list of directories to be
     searched, separated by colons (semi-colons on MS-DOS and
     MS
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: -Windows) or blanks, just like the search path used in the
     'VPATH' variable.

'vpath PATTERN'
     Clear out the search path associated with PATTERN.

'vpath'

     Clear all search paths previously specified with 'vpath'
     directives.

   A 'vpath
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ' pattern is a string containing a '%' character.  The string
must match the file name of a prerequisite that is being searched for,
the '%' character matching any sequence of zero or more characters (as
in pattern rules; *note Defining and Redefining Patt
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ern Rules: Pattern
Rules.).  For example, '%.h' matches files that end in '.h'.  (If there
is no '%', the pattern must match the prerequisite exactly, which is not
useful very often.)

   '%' characters in a 'vpath' directive's pattern can be quoted with
p
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: receding backslashes ('\').  Backslashes that would otherwise quote '%'
characters can be quoted with more backslashes.  Backslashes that quote
'%' characters or other backslashes are removed from the pattern before
it is compared to file names.  Backslash
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: es that are not in danger of
quoting '%' characters go unmolested.

   When a prerequisite fails to exist in the current directory, if the
PATTERN in a 'vpath' directive matches the name of the prerequisite
file, then the DIRECTORIES in that directive are 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: searched just like (and
before) the directories in the 'VPATH' variable.

   For example,

     vpath %.h ../headers

tells 'make' to look for any prerequisite whose name ends in '.h' in the
directory '../headers' if the file is not found in the current
di
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: rectory.

   If several 'vpath' patterns match the prerequisite file's name, then
'make' processes each matching 'vpath' directive one by one, searching
all the directories mentioned in each directive.  'make' handles
multiple 'vpath' directives in the ord
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: er in which they appear in the
makefile; multiple directives with the same pattern are independent of
each other.

   Thus,

     vpath %.c foo
     vpath %   blish
     vpath %.c bar

will look for a file ending in '.c' in 'foo', then 'blish', then 'bar',
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 
while

     vpath %.c foo:bar
     vpath %   blish

will look for a file ending in '.c' in 'foo', then 'bar', then 'blish'.

4.5.3 How Directory Searches are Performed
------------------------------------------

When a prerequisite is found through direct
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ory search, regardless of
type (general or selective), the pathname located may not be the one
that 'make' actually provides you in the prerequisite list.  Sometimes
the path discovered through directory search is thrown away.

   The algorithm 'make' uses
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  to decide whether to keep or abandon a path
found via directory search is as follows:

  1. If a target file does not exist at the path specified in the
     makefile, directory search is performed.

  2. If the directory search is successful, that path i
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s kept and this
     file is tentatively stored as the target.

  3. All prerequisites of this target are examined using this same
     method.

  4. After processing the prerequisites, the target may or may not need
     to be rebuilt:

       a. If the t
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: arget does _not_ need to be rebuilt, the path to the
          file found during directory search is used for any
          prerequisite lists which contain this target.  In short, if
          'make' doesn't need to rebuild the target then you use the
   
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:        path found via directory search.

       b. If the target _does_ need to be rebuilt (is out-of-date), the
          pathname found during directory search is _thrown away_, and
          the target is rebuilt using the file name specified in the
   
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:        makefile.  In short, if 'make' must rebuild, then the target
          is rebuilt locally, not in the directory found via directory
          search.

   This algorithm may seem complex, but in practice it is quite often
exactly what you want.

   O
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ther versions of 'make' use a simpler algorithm: if the file does
not exist, and it is found via directory search, then that pathname is
always used whether or not the target needs to be built.  Thus, if the
target is rebuilt it is created at the pathname 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: discovered during
directory search.

   If, in fact, this is the behavior you want for some or all of your
directories, you can use the 'GPATH' variable to indicate this to
'make'.

   'GPATH' has the same syntax and format as 'VPATH' (that is, a space-
or
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  colon-delimited list of pathnames).  If an out-of-date target is
found by directory search in a directory that also appears in 'GPATH',
then that pathname is not thrown away.  The target is rebuilt using the
expanded path.

4.5.4 Writing Recipes with Dire
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ctory Search
-------------------------------------------

When a prerequisite is found in another directory through directory
search, this cannot change the recipe of the rule; they will execute as
written.  Therefore, you must write the recipe with care s
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: o that it will
look for the prerequisite in the directory where 'make' finds it.

   This is done with the "automatic variables" such as '$^' (*note
Automatic Variables::).  For instance, the value of '$^' is a list of
all the prerequisites of the rule, in
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: cluding the names of the
directories in which they were found, and the value of '$@' is the
target.  Thus:

     foo.o : foo.c
             cc -c $(CFLAGS) $^ -o $@

(The variable 'CFLAGS' exists so you can specify flags for C compilation
by implicit rules
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ; we use it here for consistency so it will affect all
C compilations uniformly; *note Variables Used by Implicit Rules:
Implicit Variables.)

   Often the prerequisites include header files as well, which you do
not want to mention in the recipe.  The aut
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: omatic variable '$<' is just
the first prerequisite:

     VPATH = src:../headers
     foo.o : foo.c defs.h hack.h
             cc -c $(CFLAGS) $< -o $@

4.5.5 Directory Search and Implicit Rules
-----------------------------------------

The search throug
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: h the directories specified in 'VPATH' or with 'vpath'
also happens during consideration of implicit rules (*note Using
Implicit Rules: Implicit Rules.).

   For example, when a file 'foo.o' has no explicit rule, 'make'
considers implicit rules, such as th
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e built-in rule to compile 'foo.c'
if that file exists.  If such a file is lacking in the current
directory, the appropriate directories are searched for it.  If 'foo.c'
exists (or is mentioned in the makefile) in any of the directories, the
implicit rule 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: for C compilation is applied.

   The recipes of implicit rules normally use automatic variables as a
matter of necessity; consequently they will use the file names found by
directory search with no extra effort.

4.5.6 Directory Search for Link Libraries

Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: -----------------------------------------

Directory search applies in a special way to libraries used with the
linker.  This special feature comes into play when you write a
prerequisite whose name is of the form '-lNAME'.  (You can tell
something strange
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  is going on here because the prerequisite is normally
the name of a file, and the _file name_ of a library generally looks
like 'libNAME.a', not like '-lNAME'.)

   When a prerequisite's name has the form '-lNAME', 'make' handles it
specially by searching
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  for the file 'libNAME.so', and, if it is not
found, for the file 'libNAME.a' in the current directory, in directories
specified by matching 'vpath' search paths and the 'VPATH' search path,
and then in the directories '/lib', '/usr/lib', and 'PREFIX/lib'

Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: (normally '/usr/local/lib', but MS-DOS/MS-Windows versions of 'make'
behave as if PREFIX is defined to be the root of the DJGPP installation
tree).

   For example, if there is a '/usr/lib/libcurses.a' library on your
system (and no '/usr/lib/libcurses.so'
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  file), then

     foo : foo.c -lcurses
             cc $^ -o $@

would cause the command 'cc foo.c /usr/lib/libcurses.a -o foo' to be
executed when 'foo' is older than 'foo.c' or than
'/usr/lib/libcurses.a'.

   Although the default set of files to be sea
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: rched for is 'libNAME.so'
and 'libNAME.a', this is customizable via the '.LIBPATTERNS' variable.
Each word in the value of this variable is a pattern string.  When a
prerequisite like '-lNAME' is seen, 'make' will replace the percent in
each pattern in the
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  list with NAME and perform the above directory
searches using each library file name.

   The default value for '.LIBPATTERNS' is 'lib%.so lib%.a', which
provides the default behavior described above.

   You can turn off link library expansion completely
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  by setting this
variable to an empty value.

4.6 Phony Targets
=================

A phony target is one that is not really the name of a file; rather it
is just a name for a recipe to be executed when you make an explicit
request.  There are two reasons t
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: o use a phony target: to avoid a
conflict with a file of the same name, and to improve performance.

   If you write a rule whose recipe will not create the target file, the
recipe will be executed every time the target comes up for remaking.
Here is an ex
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ample:

     clean:
             rm *.o temp

Because the 'rm' command does not create a file named 'clean', probably
no such file will ever exist.  Therefore, the 'rm' command will be
executed every time you say 'make clean'.

   In this example, the 'cle
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: an' target will not work properly if a file
named 'clean' is ever created in this directory.  Since it has no
prerequisites, 'clean' would always be considered up to date and its
recipe would not be executed.  To avoid this problem you can explicitly
decla
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: re the target to be phony by making it a prerequisite of the
special target '.PHONY' (*note Special Built-in Target Names: Special
Targets.) as follows:

     .PHONY: clean
     clean:
             rm *.o temp

Once this is done, 'make clean' will run the 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: recipe regardless of
whether there is a file named 'clean'.

   Prerequisites of '.PHONY' are always interpreted as literal target
names, never as patterns (even if they contain '%' characters).  To
always rebuild a pattern rule consider using a "force tar
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: get" (*note
Rules without Recipes or Prerequisites: Force Targets.).

   Phony targets are also useful in conjunction with recursive
invocations of 'make' (*note Recursive Use of 'make': Recursion.).  In
this situation the makefile will often contain a var
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: iable which lists a
number of sub-directories to be built.  A simplistic way to handle this
is to define one rule with a recipe that loops over the sub-directories,
like this:

     SUBDIRS = foo bar baz

     subdirs:
             for dir in $(SUBDIRS); d
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: o \
               $(MAKE) -C $$dir; \
             done

   There are problems with this method, however.  First, any error
detected in a sub-make is ignored by this rule, so it will continue to
build the rest of the directories even when one fails.  This
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  can be
overcome by adding shell commands to note the error and exit, but then
it will do so even if 'make' is invoked with the '-k' option, which is
unfortunate.  Second, and perhaps more importantly, you cannot take full
advantage of 'make''s ability to 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: build targets in parallel (*note
Parallel Execution: Parallel.), since there is only one rule.  Each
individual makefile's targets will be built in parallel, but only one
sub-directory will be built at a time.

   By declaring the sub-directories as '.PHON
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: Y' targets (you must do
this as the sub-directory obviously always exists; otherwise it won't be
built) you can remove these problems:

     SUBDIRS = foo bar baz

     .PHONY: subdirs $(SUBDIRS)

     subdirs: $(SUBDIRS)

     $(SUBDIRS):
             $(M
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: AKE) -C $@

     foo: baz

   Here we've also declared that the 'foo' sub-directory cannot be built
until after the 'baz' sub-directory is complete; this kind of
relationship declaration is particularly important when attempting
parallel builds.

   The im
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: plicit rule search (*note Implicit Rules::) is skipped for
'.PHONY' targets.  This is why declaring a target as '.PHONY' is good
for performance, even if you are not worried about the actual file
existing.

   A phony target should not be a prerequisite of
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  a real target file; if
it is, its recipe will be run every time 'make' considers that file.  As
long as a phony target is never a prerequisite of a real target, the
phony target recipe will be executed only when the phony target is a
specified goal (*note
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  Arguments to Specify the Goals: Goals.).

   You should not declare an included makefile as phony.  Phony targets
are not intended to represent real files, and because the target is
always considered out of date make will always rebuild it then
re-execute
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  itself (*note How Makefiles Are Remade: Remaking Makefiles.).
To avoid this, 'make' will not re-execute itself if an included file
marked as phony is re-built.

   Phony targets can have prerequisites.  When one directory contains
multiple programs, it is
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  most convenient to describe all of the programs
in one makefile './Makefile'.  Since the target remade by default will
be the first one in the makefile, it is common to make this a phony
target named 'all' and give it, as prerequisites, all the individual
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 
programs.  For example:

     all : prog1 prog2 prog3
     .PHONY : all

     prog1 : prog1.o utils.o
             cc -o prog1 prog1.o utils.o

     prog2 : prog2.o
             cc -o prog2 prog2.o

     prog3 : prog3.o sort.o utils.o
             cc -o p
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: rog3 prog3.o sort.o utils.o

Now you can say just 'make' to remake all three programs, or specify as
arguments the ones to remake (as in 'make prog1 prog3').  Phoniness is
not inherited: the prerequisites of a phony target are not themselves
phony, unless 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: explicitly declared to be so.

   When one phony target is a prerequisite of another, it serves as a
subroutine of the other.  For example, here 'make cleanall' will delete
the object files, the difference files, and the file 'program':

     .PHONY: clean
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: all cleanobj cleandiff

     cleanall : cleanobj cleandiff
             rm program

     cleanobj :
             rm *.o

     cleandiff :
             rm *.diff

4.7 Rules without Recipes or Prerequisites
==========================================

If a ru
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: le has no prerequisites or recipe, and the target of the rule is
a nonexistent file, then 'make' imagines this target to have been
updated whenever its rule is run.  This implies that all targets
depending on this one will always have their recipe run.

  
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  An example will illustrate this:

     clean: FORCE
             rm $(objects)
     FORCE:

   Here the target 'FORCE' satisfies the special conditions, so the
target 'clean' that depends on it is forced to run its recipe.  There is
nothing special about 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: the name 'FORCE', but that is one name commonly
used this way.

   As you can see, using 'FORCE' this way has the same results as using
'.PHONY: clean'.

   Using '.PHONY' is more explicit and more efficient.  However, other
versions of 'make' do not suppo
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: rt '.PHONY'; thus 'FORCE' appears in many
makefiles.  *Note Phony Targets::.

4.8 Empty Target Files to Record Events
=======================================

The "empty target" is a variant of the phony target; it is used to hold
recipes for an action tha
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: t you request explicitly from time to time.
Unlike a phony target, this target file can really exist; but the file's
contents do not matter, and usually are empty.

   The purpose of the empty target file is to record, with its
last-modification time, when
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  the rule's recipe was last executed.  It
does so because one of the commands in the recipe is a 'touch' command
to update the target file.

   The empty target file should have some prerequisites (otherwise it
doesn't make sense).  When you ask to remake 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: the empty target, the
recipe is executed if any prerequisite is more recent than the target;
in other words, if a prerequisite has changed since the last time you
remade the target.  Here is an example:

     print: foo.c bar.c
             lpr -p $?
     
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:         touch print

With this rule, 'make print' will execute the 'lpr' command if either
source file has changed since the last 'make print'.  The automatic
variable '$?' is used to print only those files that have changed (*note
Automatic Variables::).

Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: 
4.9 Special Built-in Target Names
=================================

Certain names have special meanings if they appear as targets.

'.PHONY'

     The prerequisites of the special target '.PHONY' are considered to
     be phony targets.  When it is time 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: to consider such a target,
     'make' will run its recipe unconditionally, regardless of whether a
     file with that name exists or what its last-modification time is.
     *Note Phony Targets: Phony Targets.

'.SUFFIXES'

     The prerequisites of the 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: special target '.SUFFIXES' are the list of
     suffixes to be used in checking for suffix rules.  *Note
     Old-Fashioned Suffix Rules: Suffix Rules.

'.DEFAULT'

     The recipe specified for '.DEFAULT' is used for any target for
     which no rules are
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  found (either explicit rules or implicit rules).
     *Note Last Resort::.  If a '.DEFAULT' recipe is specified, every
     file mentioned as a prerequisite, but not as a target in a rule,
     will have that recipe executed on its behalf.  *Note Implicit
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  Rule
     Search Algorithm: Implicit Rule Search.

'.PRECIOUS'

     The targets which '.PRECIOUS' depends on are given the following
     special treatment: if 'make' is killed or interrupted during the
     execution of their recipes, the target is not 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: deleted.  *Note
     Interrupting or Killing 'make': Interrupts.  Also, if the target is
     an intermediate file, it will not be deleted after it is no longer
     needed, as is normally done.  *Note Chains of Implicit Rules:
     Chained Rules.  In this
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  latter respect it overlaps with the
     '.SECONDARY' special target.

     You can also list the target pattern of an implicit rule (such as
     '%.o') as a prerequisite file of the special target '.PRECIOUS' to
     preserve intermediate files created 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: by rules whose target patterns
     match that file's name.

'.INTERMEDIATE'

     The targets which '.INTERMEDIATE' depends on are treated as
     intermediate files.  *Note Chains of Implicit Rules: Chained Rules.
     '.INTERMEDIATE' with no prerequisit
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: es has no effect.

'.NOTINTERMEDIATE'

     Prerequisites of the special target '.NOTINTERMEDIATE' are never
     considered intermediate files.  *Note Chains of Implicit Rules:
     Chained Rules.  '.NOTINTERMEDIATE' with no prerequisites causes all
     
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: targets to be treated as not intermediate.

     If the prerequisite is a target pattern then targets that are built
     using that pattern rule are not considered intermediate.

'.SECONDARY'

     The targets which '.SECONDARY' depends on are treated as

Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:      intermediate files, except that they are never automatically
     deleted.  *Note Chains of Implicit Rules: Chained Rules.

     '.SECONDARY' can be used to avoid redundant rebuilds in some
     unusual situations.  For example:

          hello.bin: 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: hello.o bye.o
                  $(CC) -o $@ $^

          %.o: %.c
                  $(CC) -c -o $@ $<

          .SECONDARY: hello.o bye.o

     Suppose 'hello.bin' is up to date in regards to the source files,
     _but_ the object file 'hello.o' is miss
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ing.  Without '.SECONDARY'
     make would rebuild 'hello.o' then rebuild 'hello.bin' even though
     the source files had not changed.  By declaring 'hello.o' as
     '.SECONDARY' 'make' will not need to rebuild it and won't need to
     rebuild 'hello.b
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: in' either.  Of course, if one of the source files
     _were_ updated then all object files would be rebuilt so that the
     creation of 'hello.bin' could succeed.

     '.SECONDARY' with no prerequisites causes all targets to be treated
     as secondar
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: y (i.e., no target is removed because it is considered
     intermediate).

'.SECONDEXPANSION'

     If '.SECONDEXPANSION' is mentioned as a target anywhere in the
     makefile, then all prerequisite lists defined _after_ it appears
     will be expanded 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: a second time after all makefiles have been read
     in.  *Note Secondary Expansion: Secondary Expansion.

'.DELETE_ON_ERROR'

     If '.DELETE_ON_ERROR' is mentioned as a target anywhere in the
     makefile, then 'make' will delete the target of a rule 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: if it has
     changed and its recipe exits with a nonzero exit status, just as it
     does when it receives a signal.  *Note Errors in Recipes: Errors.

'.IGNORE'

     If you specify prerequisites for '.IGNORE', then 'make' will ignore
     errors in ex
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ecution of the recipe for those particular files.  The
     recipe for '.IGNORE' (if any) is ignored.

     If mentioned as a target with no prerequisites, '.IGNORE' says to
     ignore errors in execution of recipes for all files.  This usage of
     '.IG
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: NORE' is supported only for historical compatibility.  Since
     this affects every recipe in the makefile, it is not very useful;
     we recommend you use the more selective ways to ignore errors in
     specific recipes.  *Note Errors in Recipes: Error
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s.

'.LOW_RESOLUTION_TIME'

     If you specify prerequisites for '.LOW_RESOLUTION_TIME', 'make'
     assumes that these files are created by commands that generate low
     resolution time stamps.  The recipe for the '.LOW_RESOLUTION_TIME'
     target are
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  ignored.

     The high resolution file time stamps of many modern file systems
     lessen the chance of 'make' incorrectly concluding that a file is
     up to date.  Unfortunately, some hosts do not provide a way to set
     a high resolution file time
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  stamp, so commands like 'cp -p' that
     explicitly set a file's time stamp must discard its sub-second
     part.  If a file is created by such a command, you should list it
     as a prerequisite of '.LOW_RESOLUTION_TIME' so that 'make' does not
     m
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: istakenly conclude that the file is out of date.  For example:

          .LOW_RESOLUTION_TIME: dst
          dst: src
                  cp -p src dst

     Since 'cp -p' discards the sub-second part of 'src''s time stamp,
     'dst' is typically slightly 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: older than 'src' even when it is up to
     date.  The '.LOW_RESOLUTION_TIME' line causes 'make' to consider
     'dst' to be up to date if its time stamp is at the start of the
     same second that 'src''s time stamp is in.

     Due to a limitation of t
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: he archive format, archive member time
     stamps are always low resolution.  You need not list archive
     members as prerequisites of '.LOW_RESOLUTION_TIME', as 'make' does
     this automatically.

'.SILENT'

     If you specify prerequisites for '.SI
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: LENT', then 'make' will not
     print the recipe used to remake those particular files before
     executing them.  The recipe for '.SILENT' is ignored.

     If mentioned as a target with no prerequisites, '.SILENT' says not
     to print any recipes bef
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ore executing them.  You may also use more
     selective ways to silence specific recipe command lines.  *Note
     Recipe Echoing: Echoing.  If you want to silence all recipes for a
     particular run of 'make', use the '-s' or '--silent' option (*note

Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:      Options Summary::).

'.EXPORT_ALL_VARIABLES'

     Simply by being mentioned as a target, this tells 'make' to export
     all variables to child processes by default.  This is an
     alternative to using 'export' with no arguments.  *Note
     Commu
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: nicating Variables to a Sub-'make': Variables/Recursion.

'.NOTPARALLEL'

     If '.NOTPARALLEL' is mentioned as a target with no prerequisites,
     all targets in this invocation of 'make' will be run serially, even
     if the '-j' option is given.  Any
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  recursively invoked 'make'
     command will still run recipes in parallel (unless its makefile
     also contains this target).

     If '.NOTPARALLEL' has targets as prerequisites, then all the
     prerequisites of those targets will be run serially.  
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: This
     implicitly adds a '.WAIT' between each prerequisite of the listed
     targets.  *Note Disabling Parallel Execution: Parallel Disable.

'.ONESHELL'

     If '.ONESHELL' is mentioned as a target, then when a target is
     built all lines of the r
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ecipe will be given to a single invocation
     of the shell rather than each line being invoked separately.  *Note
     Recipe Execution: Execution.

'.POSIX'

     If '.POSIX' is mentioned as a target, then the makefile will be
     parsed and run in POS
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: IX-conforming mode.  This does _not_ mean that
     only POSIX-conforming makefiles will be accepted: all advanced GNU
     'make' features are still available.  Rather, this target causes
     'make' to behave as required by POSIX in those areas where 'ma
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ke''s
     default behavior differs.

     In particular, if this target is mentioned then recipes will be
     invoked as if the shell had been passed the '-e' flag: the first
     failing command in a recipe will cause the recipe to fail
     immediately
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: .

   Any defined implicit rule suffix also counts as a special target if
it appears as a target, and so does the concatenation of two suffixes,
such as '.c.o'.  These targets are suffix rules, an obsolete way of
defining implicit rules (but a way still wi
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: dely used).  In principle,
any target name could be special in this way if you break it in two and
add both pieces to the suffix list.  In practice, suffixes normally
begin with '.', so these special target names also begin with '.'.
*Note Old-Fashioned Su
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ffix Rules: Suffix Rules.

4.10 Multiple Targets in a Rule
===============================

When an explicit rule has multiple targets they can be treated in one of
two possible ways: as independent targets or as grouped targets.  The
manner in which they 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: are treated is determined by the separator that
appears after the list of targets.

Rules with Independent Targets
..............................

Rules that use the standard target separator, ':', define independent
targets.  This is equivalent to writing
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  the same rule once for each
target, with duplicated prerequisites and recipes.  Typically, the
recipe would use automatic variables such as '$@' to specify which
target is being built.

   Rules with independent targets are useful in two cases:

   * You 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: want just prerequisites, no recipe.  For example:

          kbd.o command.o files.o: command.h

     gives an additional prerequisite to each of the three object files
     mentioned.  It is equivalent to writing:

          kbd.o: command.h
          com
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: mand.o: command.h
          files.o: command.h

   * Similar recipes work for all the targets.  The automatic variable
     '$@' can be used to substitute the particular target to be remade
     into the commands (*note Automatic Variables::).  For example
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: :

          bigoutput littleoutput : text.g
                  generate text.g -$(subst output,,$@) > $@

     is equivalent to

          bigoutput : text.g
                  generate text.g -big > bigoutput
          littleoutput : text.g
               
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:    generate text.g -little > littleoutput

     Here we assume the hypothetical program 'generate' makes two types
     of output, one if given '-big' and one if given '-little'.  *Note
     Functions for String Substitution and Analysis: Text Functions, f
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: or
     an explanation of the 'subst' function.

   Suppose you would like to vary the prerequisites according to the
target, much as the variable '$@' allows you to vary the recipe.  You
cannot do this with multiple targets in an ordinary rule, but you ca
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: n do
it with a "static pattern rule".  *Note Static Pattern Rules: Static
Pattern.

Rules with Grouped Targets
..........................

If instead of independent targets you have a recipe that generates
multiple files from a single invocation, you can e
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: xpress that
relationship by declaring your rule to use _grouped targets_.  A grouped
target rule uses the separator '&:' (the '&' here is used to imply
"all").

   When 'make' builds any one of the grouped targets, it understands
that all the other targets
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  in the group are also updated as a result of
the invocation of the recipe.  Furthermore, if only some of the grouped
targets are out of date or missing 'make' will realize that running the
recipe will update all of the targets.  Finally, if any of the gro
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: uped
targets are out of date, all the grouped targets are considered out of
date.

   As an example, this rule defines a grouped target:

     foo bar biz &: baz boz
             echo $^ > foo
             echo $^ > bar
             echo $^ > biz

   Durin
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: g the execution of a grouped target's recipe, the automatic
variable '$@' is set to the name of the particular target in the group
which triggered the rule.  Caution must be used if relying on this
variable in the recipe of a grouped target rule.

   Unlik
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: e independent targets, a grouped target rule _must_ include a
recipe.  However, targets that are members of a grouped target may also
appear in independent target rule definitions that do not have recipes.

   Each target may have only one recipe associate
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: d with it.  If a
grouped target appears in either an independent target rule or in
another grouped target rule with a recipe, you will get a warning and
the latter recipe will replace the former recipe.  Additionally the
target will be removed from the pre
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: vious group and appear only in the
new group.

   If you would like a target to appear in multiple groups, then you
must use the double-colon grouped target separator, '&::' when declaring
all of the groups containing that target.  Grouped double-colon tar
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: gets
are each considered independently, and each grouped double-colon rule's
recipe is executed at most once, if at least one of its multiple targets
requires updating.

4.11 Multiple Rules for One Target
==================================

One file can be
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  the target of several rules.  All the prerequisites
mentioned in all the rules are merged into one list of prerequisites for
the target.  If the target is older than any prerequisite from any rule,
the recipe is executed.

   There can only be one recipe 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: to be executed for a file.  If more than
one rule gives a recipe for the same file, 'make' uses the last one
given and prints an error message.  (As a special case, if the file's
name begins with a dot, no error message is printed.  This odd behavior
is on
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ly for compatibility with other implementations of 'make'... you
should avoid using it).  Occasionally it is useful to have the same
target invoke multiple recipes which are defined in different parts of
your makefile; you can use "double-colon rules" (*no
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: te Double-Colon::)
for this.

   An extra rule with just prerequisites can be used to give a few extra
prerequisites to many files at once.  For example, makefiles often have
a variable, such as 'objects', containing a list of all the compiler
output files
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  in the system being made.  An easy way to say that all of
them must be recompiled if 'config.h' changes is to write the following:

     objects = foo.o bar.o
     foo.o : defs.h
     bar.o : defs.h test.h
     $(objects) : config.h

   This could be inse
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: rted or taken out without changing the rules that
really specify how to make the object files, making it a convenient form
to use if you wish to add the additional prerequisite intermittently.

   Another wrinkle is that the additional prerequisites could 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: be
specified with a variable that you set with a command line argument to
'make' (*note Overriding Variables: Overriding.).  For example,

     extradeps=
     $(objects) : $(extradeps)

means that the command 'make extradeps=foo.h' will consider 'foo.h' a
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s a
prerequisite of each object file, but plain 'make' will not.

   If none of the explicit rules for a target has a recipe, then 'make'
searches for an applicable implicit rule to find one *note Using
Implicit Rules: Implicit Rules.).

4.12 Static Patter
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: n Rules
=========================

"Static pattern rules" are rules which specify multiple targets and
construct the prerequisite names for each target based on the target
name.  They are more general than ordinary rules with multiple targets
because the t
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: argets do not have to have identical prerequisites.  Their
prerequisites must be _analogous_, but not necessarily _identical_.

4.12.1 Syntax of Static Pattern Rules
-------------------------------------

Here is the syntax of a static pattern rule:

     
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: TARGETS ...: TARGET-PATTERN: PREREQ-PATTERNS ...
             RECIPE
             ...

The TARGETS list specifies the targets that the rule applies to.  The
targets can contain wildcard characters, just like the targets of
ordinary rules (*note Using Wildc
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ard Characters in File Names:
Wildcards.).

   The TARGET-PATTERN and PREREQ-PATTERNS say how to compute the
prerequisites of each target.  Each target is matched against the
TARGET-PATTERN to extract a part of the target name, called the "stem".
This stem
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  is substituted into each of the PREREQ-PATTERNS to make the
prerequisite names (one from each PREREQ-PATTERN).

   Each pattern normally contains the character '%' just once.  When the
TARGET-PATTERN matches a target, the '%' can match any part of the
tar
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: get name; this part is called the "stem".  The rest of the pattern
must match exactly.  For example, the target 'foo.o' matches the pattern
'%.o', with 'foo' as the stem.  The targets 'foo.c' and 'foo.out' do not
match that pattern.

   The prerequisite na
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: mes for each target are made by substituting the
stem for the '%' in each prerequisite pattern.  For example, if one
prerequisite pattern is '%.c', then substitution of the stem 'foo' gives
the prerequisite name 'foo.c'.  It is legitimate to write a prereq
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: uisite
pattern that does not contain '%'; then this prerequisite is the same
for all targets.

   '%' characters in pattern rules can be quoted with preceding
backslashes ('\').  Backslashes that would otherwise quote '%'
characters can be quoted with more
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  backslashes.  Backslashes that quote
'%' characters or other backslashes are removed from the pattern before
it is compared to file names or has a stem substituted into it.
Backslashes that are not in danger of quoting '%' characters go
unmolested.  For e
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: xample, the pattern 'the\%weird\\%pattern\\' has
'the%weird\' preceding the operative '%' character, and 'pattern\\'
following it.  The final two backslashes are left alone because they
cannot affect any '%' character.

   Here is an example, which compile
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s each of 'foo.o' and 'bar.o' from
the corresponding '.c' file:

     objects = foo.o bar.o

     all: $(objects)

     $(objects): %.o: %.c
             $(CC) -c $(CFLAGS) $< -o $@

Here '$<' is the automatic variable that holds the name of the
prerequisi
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: te and '$@' is the automatic variable that holds the name of
the target; see *note Automatic Variables::.

   Each target specified must match the target pattern; a warning is
issued for each target that does not.  If you have a list of files, only
some of
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  which will match the pattern, you can use the 'filter' function
to remove non-matching file names (*note Functions for String
Substitution and Analysis: Text Functions.):

     files = foo.elc bar.o lose.o

     $(filter %.o,$(files)): %.o: %.c
          
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:    $(CC) -c $(CFLAGS) $< -o $@
     $(filter %.elc,$(files)): %.elc: %.el
             emacs -f batch-byte-compile $<

In this example the result of '$(filter %.o,$(files))' is 'bar.o
lose.o', and the first static pattern rule causes each of these object
f
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: iles to be updated by compiling the corresponding C source file.  The
result of '$(filter %.elc,$(files))' is 'foo.elc', so that file is made
from 'foo.el'.

   Another example shows how to use '$*' in static pattern rules:

     bigoutput littleoutput : %
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: output : text.g
             generate text.g -$* > $@

When the 'generate' command is run, '$*' will expand to the stem, either
'big' or 'little'.

4.12.2 Static Pattern Rules versus Implicit Rules
-------------------------------------------------

A stati
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: c pattern rule has much in common with an implicit rule defined
as a pattern rule (*note Defining and Redefining Pattern Rules: Pattern
Rules.).  Both have a pattern for the target and patterns for
constructing the names of prerequisites.  The difference i
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s in how
'make' decides _when_ the rule applies.

   An implicit rule _can_ apply to any target that matches its pattern,
but it _does_ apply only when the target has no recipe otherwise
specified, and only when the prerequisites can be found.  If more tha
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: n
one implicit rule appears applicable, only one applies; the choice
depends on the order of rules.

   By contrast, a static pattern rule applies to the precise list of
targets that you specify in the rule.  It cannot apply to any other
target and it inva
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: riably does apply to each of the targets specified.
If two conflicting rules apply, and both have recipes, that's an error.

   The static pattern rule can be better than an implicit rule for these
reasons:

   * You may wish to override the usual implicit
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  rule for a few files
     whose names cannot be categorized syntactically but can be given in
     an explicit list.

   * If you cannot be sure of the precise contents of the directories
     you are using, you may not be sure which other irrelevant file
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: s
     might lead 'make' to use the wrong implicit rule.  The choice might
     depend on the order in which the implicit rule search is done.
     With static pattern rules, there is no uncertainty: each rule
     applies to precisely the targets specifie
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: d.

4.13 Double-Colon Rules
=======================

"Double-colon" rules are explicit rules written with '::' instead of ':'
after the target names.  They are handled differently from ordinary
rules when the same target appears in more than one rule.  Pat
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: tern rules
with double-colons have an entirely different meaning (*note
Match-Anything Rules::).

   When a target appears in multiple rules, all the rules must be the
same type: all ordinary, or all double-colon.  If they are double-colon,
each of them is
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  independent of the others.  Each double-colon rule's
recipe is executed if the target is older than any prerequisites of that
rule.  If there are no prerequisites for that rule, its recipe is always
executed (even if the target already exists).  This can 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: result in
executing none, any, or all of the double-colon rules.

   Double-colon rules with the same target are in fact completely
separate from one another.  Each double-colon rule is processed
individually, just as rules with different targets are proce
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ssed.

   The double-colon rules for a target are executed in the order they
appear in the makefile.  However, the cases where double-colon rules
really make sense are those where the order of executing the recipes
would not matter.

   Double-colon rules 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: are somewhat obscure and not often very useful;
they provide a mechanism for cases in which the method used to update a
target differs depending on which prerequisite files caused the update,
and such cases are rare.

   Each double-colon rule should speci
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: fy a recipe; if it does not, an
implicit rule will be used if one applies.  *Note Using Implicit Rules:
Implicit Rules.

4.14 Generating Prerequisites Automatically
===========================================

In the makefile for a program, many of the rul
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: es you need to write often
say only that some object file depends on some header file.  For
example, if 'main.c' uses 'defs.h' via an '#include', you would write:

     main.o: defs.h

You need this rule so that 'make' knows that it must remake 'main.o'
wh
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: enever 'defs.h' changes.  You can see that for a large program you
would have to write dozens of such rules in your makefile.  And, you
must always be very careful to update the makefile every time you add or
remove an '#include'.

   To avoid this hassle,
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  most modern C compilers can write these rules
for you, by looking at the '#include' lines in the source files.
Usually this is done with the '-M' option to the compiler.  For example,
the command:

     cc -M main.c

generates the output:

     main.o : m
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: ain.c defs.h

Thus you no longer have to write all those rules yourself.  The compiler
will do it for you.

   Note that such a rule constitutes mentioning 'main.o' in a makefile,
so it can never be considered an intermediate file by implicit rule
search. 
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload:  This means that 'make' won't ever remove the file after using
it; *note Chains of Implicit Rules: Chained Rules.

Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 1 Payload: None
Packet - srcAddr: A dstAddr: B seqNum: 0 ackNum: 0 SYNFLag: 0 ACKFlag: 1 FINFlag: 0 Payload: None
